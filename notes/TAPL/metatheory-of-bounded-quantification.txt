Metatheory of Bounded Quantification
====================================

In this chapter we develop subtyping and typechecking algorithms for F<:. We study both the kernel and the full variants of the system, which behave somewhat differently. Some properties are enjoyed by both but harder to prove for the full variant, while others are lost outright in full F<: - the price we pay for the extra expressiveness of this system.


Exposure
--------

In the typechecking algorithm for the simply typed lambda-calculus with subtyping, the key idea was to calculate a minimal type for each term from the minimal types of its subterms. We can use the same basic idea for F<:, but we need to take into account one small complication arising from the presence of type variables in the system. Consider the term

  f = λX<:Nat->Nat. λy:X. y 5;
  > f : "X<:Nat->Nat. X -> Nat

This term is clearly well typed, since the type of the variable y in the application y 5 can be promoted to Nat->Nat by T-SUB. But the minimal type of y is X, which is not an arrow type. In order to find the minimal type of the whole application, we need to find the smallest arrow type that y possesses - i.e., the minimal arrow type that is a supertype of the type variable X. Not too surprisingly, we can find this type by promoting the minimal type of y until it becomes something other than a type variable.

Formally, we write Г |- S |^ T (pronounced "S exposes to T under Г") to mean "T is the least nonvariable supertype of S." Exposure is defined by repeated promotion of variables, as shown in Figure below:

  X<:T <- Г    Г |-> T |^ T'
  --------------------------    XA-PROMOTE
  Г |-> X |^ T'

  T is not a type variable
  ------------------------    XA-OTHER
  Г |-> T |^ T

It is easy to see that these rules define a total function. Moreover, the result of exposing a type is always the least supertype that has some shape other than a variable.

Lemma [Exposure]: Suppose Г |- S |^ T. Then:
  1. Г |- S <: T.
  2. If Г |- S <: U and U is not a variable, then Г |- T <: U.


Minimal Typing
--------------

The algorithm for calculating minimal types is now built along the same lines as the one for the simply typed lambda-calculus with subtyping, with one additional twist: when we typecheck an application, we calculate the minimal type of the left-hand side and then expose this type to obtain an arrow type, as shown in Figure below. If the exposure of the left-hand side does not yield an arrow type, then rule TA-APP does not apply and the application is ill-typed. Similarly, we typecheck a type application by exposing its left-hand side to obtain a quantified type.

  x:T <- Г
  --------    TA-VAR
  Г |- x:T

  Г,x:T1 |- t2:T2
  ----------------------    TA-ABS
  Г |- λx:T1.t2 : T1->T2

  Г |- t1:T1    Г |- T1 |^ (T11->T12)    Г |- t2:T2    Г |- T2<:T11
  -----------------------------------------------------------------    TA-APP
  Г |- t1 t2 : T12

  Г,X<:T1 |- t2:T2
  ------------------------    TA-TABS
  Г |- λX<:T1.t2:"X<:T1.T2

  Г |- t1:T1    Г |- T1 |^ "X<:T11.T12    Г |- T2<:T11
  ----------------------------------------------------    TA-TAPP
  Г |- t1 [T2] : [X |-> T2]T12

Theorem [Minimal Typing]:
  1. If Г |-> t:T  , then Г |- t:T.
  2. If Г |- t:T, then Г |- t:M with Г |- M<:T.
                
Corollary [Decidability of Typing]: The kernel F<: typing relation is decidable, given a decision procedure for the subtype relation.


Subtyping in Kernel F<:
-----------------------

We remarked that the declarative subtype relation for the simply typed lambda-calculus with subtyping is not syntax directed - i.e., it cannot be read directly as a subtyping algorithm - for two reasons: (1) the conclusions of S-REFL and S-TRANS overlap with the other rules (so, reading the rules from bottom to top, we would not know which one to try to apply), and (2) the premises of S-TRANS mention a metavariable that does not appear in the conclusion (which a naive algorithm would have to somehow "guess"). We saw that these problems can be fixed by simply dropping the two offending rules from the system, but that, before doing so, we must fix up the system a little by combining the three separate record subtyping rules into one.  

For kernel F<:, the story is similar. Again, the offending rules are S-REFL and S-TRANS, and we obtain an algorithm by dropping these rules and fixing up the remaining rules a little to account for the essential uses of the dropped rules.

In the simply typed lambda-calculus with subtyping, there were no essential uses of the reflexivity rule - we could just drop it without changing the set of derivable subtyping statements. In F<:, on the other hand, subtyping statements of the form Г |- X <: X can be proved only by reflexivity. So, when we remove the full reflexivity rule, we should add in its place a restricted reflexivity axiom that applies only to variables.

Similarly, to eliminate S-TRANS, we must first understand which of its uses are essential. Here, the interesting interaction is with the S-TVAR rule, which allows assumptions about type variables to be used in deriving subtyping statements. For example, if Г = W<:Top, X<:W, Y<:X, Z<:Y, then the statement Г |- Z <: W cannot be proved if S-TRANS is removed from the system. An instance of S-TRANS whose left-hand subderivation is an instance of the axiom S-TVAR, as in

Z<:Y <- Г              ...
--------- (S-TVAR)  ----------
Г |- Z<:Y           Г |- Y<:W
------------------------------------ (S-TRANS)
Г |- Z<:W

Fortunately, derivations of this form are the only essential uses of transitivity in subtyping. This observation can be made precise by introducing a new subtyping rule

X<:U <- Г    Г |- U<:T
----------------------
Г |- X<:T

that captures exactly this pattern of variable lookup followed by transitivity, and showing that replacing the transitivity and variable rules by this one does not change the set of derivable subtyping statements.

These changes lead us to the algorithmic subtype relation for kernel F<:, shown below. We add an arrowhead to the turnstile symbol in algorithmic typing statements so that we can distinguish them from original typing statements in discussions involving both.

Г |-> S<:Top    (SA-TOP)

Г |-> X<:X      (SA-REFL-TVAR)

X<:U <- Г    Г |-> U<:T
----------------------    (SA-TRANS-TVAR)
Г |-> X<:T

Г |-> T1<:S1    Г |-> S2<:T2
--------------------------    (SA-ARROW)
Г |-> S1->S2 <: T1->T2

Г,X<:U1 |-> S2<:T2
---------------------------   (SA-ALL)
Г |-> "X<:U1.S2 <: "X<:U1.T2

The fact that the new SA-REFL-TVAR and SA-TRANS-TVAR rules are sufficient replacements for the old reflexivity and transitivity rules is captured by the next two lemmas.

Lemma [Reflexivity of the Algorithmic Subtype Relation]: Г |-> T<:T is provable for every Г and T.

Lemma [Transitivity of the Algorithmic Subtype Relation]: If Г |-> S<:Q and Г |-> Q<:T, then Г |-> S<:T.

Theorem [Soundness and Completeness of Algorithmic Subtyping]: Г |- S<:T iff Г |-> S<:T

Finally, we need to check that the subtyping rules define an algorithm that is total - i.e., that terminates on all inputs. We do this by assigning a weight to each subtyping statement and checking that the algorithmic rules all have conclusions with strictly greater weight than their premises.

Definition: The weight of a type T in a context Г, written weightГ(T), is defined as follows:

  weightГ(X)         = weightГ1(U) + 1, if Г = Г1,X<:U,Г2
  weightГ(Top)       = 1
  weightГ(T1->T2)    = weightГ(T1) + weightГ(T2) + 1
  weightГ("X<:T1.T2) = weightГ,X<:T1(T2) + 1

The weight of a subtyping statement Г |- S<:T is the maximum weight of S and T in Г.

Theorem: The subtyping algorithm terminates on all inputs.

Corollary: Subtyping in kernel F<: is decidable.

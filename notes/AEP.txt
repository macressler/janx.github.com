============================= Agile Estimating and Planning ============================= 

================================
Part I. The Problem and The Goal
================================


1. The Purpose of Planning
==========================

A good planning process supports yourt project by:

  * Reducing risk 

    find risks at the very beginning

  * Reducing uncertainty 

    understand what a user want better

  * Supporting better decision making

  * Establishing trust

    Frequent reliable delivery of promised features builds trust between the developers of a product and the customers of that product. Reliable estimates enable reliable delivery.
    Reliable estimates benefit developers by allowing them to work at a sustainable pace. This leads to higher quality code and fewer bugs. These, in turn, lead back to more reliable estimates because less time is spent on highly unpredictable work such as bug fixing.

  * Conveying information

    A plan conveys expectations and describes one possibility of what may come to pass over the course of a project. A plan does not guarantee an exact set of features on an exact date at a specified cost. A plan does, however, communicate and establish a set of baseline expectations.


A good plan is one that stakeholders find sufficiently reliable that they can use it as the basis for making decisions. 

e.g. You'll ship a new release six months later. You create a plan that describes a set of features that are certain to be in the new version and another set of features that may or may not be included, depending on how well things progress.

A plan, although inaccurate, was even more likely useful if we consider that it should have been updated regularly throughout the course of the project. In that case, a one-month late delivery should not have been a last-minute surprise to anyone.

This book is about agile planning, not agile plans. Plans are documents or figures, they are snapshots of how we believe a project might unfold over an uncertain future. Planning is an activity. Agile planning shifts the emphasis from the plan to the planning. Agile planning balances the effort and investment in planning with the knowledge that we will revise the plan through the course of the project. An agile plan is one that we are not only willing but anxious to change. We don’t want to change the plan just for the sake of changing, but we want to change because change means we’ve learned something or that we’ve avoided a mistake.

Just because we’re changing the plan does not mean we change the dates.  We may or may not do that. But if we learn we were wrong about some aspect of the target product and need to do something about it, then the plan needs to change. There are many ways we can change the plan without changing the date.  We can drop a feature, we can reduce the scope of a feature, we can possibly add people to the project, and so on.

Because we acknowledge that we cannot totally define a project at its outset, it is important that we do not perform all of a project’s planning at the outset.  Agile planning is spread more or less evenly across the duration of a project. Release planning sets the stage and is followed by a number of rounds of iteration planning, after which the entire process is repeated perhaps a handful of times on a project.

So in defining agile planning we find that it:

  * Is focused more on the planning than the plan
  * Encourages change
  * Results in plans that are easily changed
  * Is spread throughout the project

Estimates given early in a project are far less accurate than those given later. This progressive refinement is shown in the cone of uncertainty.


2. Why Planning Fails
=====================

* 2/3 traditional projects cost more than plan
* 2/3 features in a released product is not need
* 100% traditional projects exceeds its schedule

Planning Is By Activity Rather Than Feature
-------------------------------------------

1. Activities Don't Finish Early:

"Work expands so as to fill the time available for its completion." - Parkinson’s Law (1957)

Parkinson is saying that we take as much time to complete an activity as we think we’ll be allowed. If there’s a Gantt chart hanging on the wall that says an activity is expected to take five days then the programmer assigned to that activity will generally make sure the activity takes the full five days. She may do this by adding a few bells and whistles if it looks like she’ll finish early (a practice known as gold-plating). Or, she may split time between the activity and researching some hot, new technology she thinks may be useful. What she will not do very often is finish the activity early. In many organizations, if she finishes early, her boss may accuse her of having given a padded estimate. Or, her boss may expect her to finish more activities early. Why risk either of these scenarios when a little web surfing can make the activity come in on schedule instead?

2. Lateness Is Passed Down the Schedule

An early start requires a combination of things to go well, a late start can be caused by one thing going wrong.

The problem is compounded because we’ve already established that activities will rarely finish early. This means that activities will start late and that the lateness will get passed down the schedule. 

3. Activities Are Not Independent

Many activities in a typical project plan are not independent. When an activity takes longer than planned, all similar activities are also likely to take longer than planned.


Multitasking Causes Further Delays
----------------------------------

A second reason why traditional approaches to planning often fail is multitasking, which is defined as simultaneously working on multiple tasks. Multitasking exacts a horrible toll on productivity. Clark and Wheelwright (1993) studied the effects of multitasking and found that the time an individual spends on value-adding work drops rapidly when the individual is working on more than two tasks. 

Multitasking becomes a problem on a traditionally planned project for two primary reasons. First, work is typically assigned well in advance of when the work will begin and it is impossible to efficiently allocate work in advance. As signing work to individuals rather than to groups exacerbates the problem. Second, it encourages focusing on achieving a high level of utilization of all individuals on the project rather than on maintaining sufficient slack to cope with the inherent variability in typical project tasks. Loading everyone to 100% of capacity has the same effect as loading a highway to 100% of capacity: no one can make any forward progress.


Features Are Not Developed By Priority
--------------------------------------

Many traditional plans are created with the assumption that all identified activities will be completed. This means that work is typically prioritized and sequenced for the convenience of the development team.

Traditional thinking says that if all work will be completed then project customers have no preference about the sequence in which that work is done. This leads to the development team working on features in what appears to the customer as a relatively haphazard order. Then, with the end of the project approaching, the team scrambles to meet the schedule by dropping features. Since there was no attempt to work on features in a priority order, some of the features dropped are of greater value than those that are delivered.


We Ignore Uncertainty
---------------------

A fourth shortcoming with traditional approaches to planning is the failure to acknowledge uncertainty. We ignore uncertainty about the product and assume that the initial requirements analysis led to a complete and perfect specification of the product. We assume that users will not change their minds, refine their opinions, or come up with new needs during the period covered by the plan.

Similarly, we ignore uncertainty about how we will build the product and pretend we can assign precise estimates (“2 weeks”) to imprecise work. As stated earlier in this chapter, we cannot hope to identify every activity that will be needed in the course of a project. Yet we often fail to acknowledge this in the plans we create.

Even with all this uncertainty, schedules are often expressed as a single, unqualified date: “We will ship on June 30,” for example. During the earliest part of a project we are the most uncertain. The estimates we give should reflect our uncertainty. One way of doing this is by expressing the end date as a range. “We’ll ship sometime between June and August,” for example. As the project progresses and as uncertainty and risk are removed from the project, estimates can be refined and made more precise.

The best way of dealing with uncertainty is to iterate. To reduce uncertainty about what the product should be, work in short iterations and show (or, ideally, give) working software to users every few weeks. Uncertainty about how to develop the product is similarly reduced by iterating. For example, missing tasks can be added to plans, bad estimates can be corrected, and so on. In this way, the focus shifts from the plan to the planning.


Estimates Become Commitments
----------------------------

Embedded within each and every estimate is a probability that the work will be completed in the estimated time. Suppose your team has been asked to develop a new high-end word processor. The probability of finishing this by the end of the week is 0%. The probability of finishing it in ten years is 100%. If I ask you for an estimate and you tell me the end of the week, that estimate comes with a probability of 0%. If the estimate you give me is ten years, that estimate comes with a probability of 100%. Each estimate between the end of the week and ten years from now comes with its own probability between 0% and 100% (Armour 2002).

A problem with traditional planning can arise if the project team or its stakeholders equate estimating with committing. As Phillip Armour (2002) points out, an estimate is a probability and a commitment cannot be made to a probability. Commitments are made to dates. Normally the date that a team is asked (or told) to commit to is one to which they would assign a less than 100% probability. Prior to making such a commitment the team needs to assess a variety of business factors and risks. It is important that they be given this opportunity and that every estimate does not become an implicit commitment.


3. An Agile Approach
====================


Agile Manifesto, Feb. 2001
--------------------------

* Individuals and interactions over processes and tools

Agile teams value individuals and interactions over processes and tools because they know that a well-functioning team of great individuals with mediocre tools will always outperform a dysfunctional team of mediocre individuals with great tools and processes. Great software is made by great individuals and as an industry we have tried too long with too little success to define a development process that relegates individuals to replaceable cogs in the machinery. Agile processes acknowledge the unique strengths (and weaknesses) of individuals and capitalize on these rather than attempting to make everyone homogeneous.

* Working software over comprehensive documentation

Agile teams value working software over comprehensive documentation because it leads them to have a stable, incrementally enhanced version of the product at the end of each iteration. This makes it possible to collect early, frequent feedback on both the product and the process. As the developed software grows each iteration it can be shown to likely or actual users. Feedback from these users is fed back into the development process to make sure that the team is always working on the highest-valued features and that those features will satisfy user expectations.

* Customer collaboration over contract negotiation

Customer collaboration is valued over contract negotiation because agile teams would like all parties to the project to be working toward the same set of goals. Contract negotiation sometimes sets the development team and the project customer at odds right from the start. I enjoy playing most games and when my oldest daughter was four, I bought her a “cooperative game” because it looked like a game she’d enjoy and because I had no idea how a cooperative game could be fun. In the game I bought her, a princess is placed under a spell and players need to remove obstacles (a moat, a locked door, and so on) that are between them and the princess. Players take turns as in most games but the goal is to collaboratively remove obstacles and save the princess. All players win or all players lose. The game is surprisingly fun and we’d like software teams and customers to approach projects with this same attitude of collaboration and shared goals. Yes, contracts are often necessary but the terms and details in a contract can exert great influence on whether the different parties are set on a collaborative or a competitive effort.

* Responding to change over following a plan

Agile teams value responding to change over following a plan because their ultimate focus is on delivering as much value as possible to the project’s customer and users. For all but the simplest projects, it is impossible for users to know every detail of every feature they want. It is inevitable that users will come up with new ideas and almost as inevitable that they will decide that some features desired today will become lower priorities tomorrow. To an agile team, a plan is one view of the future but many views are possible. As a team gains knowledge and experience they will factor these into the plan. Perhaps the team is progressing faster or slower than initially expected, perhaps users like one set of features more than expected but don’t like another feature that was initially considered critical.


An Agile Approach To Projects
-----------------------------

* Work as one team

Critical to the success of a project is that all project participants view themselves as one team aimed at a common goal. There is no room for a “throw it over the wall” mentality on an agile project. Analysts do not throw requirements over the wall to designers. Designers and architects do not throw designs over a wall to coders; coders do not throw half-tested code over a wall to testers. A successful agile team must have a we’re-all-in-this-together mindset. While an agile team should work together as one whole team, there are a number of specific roles on the team. It was worth identifying and clarifying those roles that play a part in agile estimating and planning.

The first role is the product owner. The primary duties of the product owner include making sure that all team members are purusing a common vision for the project, establishing priorities so that the highest-valued functionality is always being worked on, and making decisions that lead to a good return on the investment in the project. When developing commercial software, the product owner is often someone from the marketing or product management side of the company. When developing software for internal use, the product owner may instead be a user, the users’ manager, an analyst, or the person funding the project. (Raphael!)

A second role is that of customer. The customer is the person who has made the decision to fund the project or to buy the software. On a project developing software for internal use, the customer is usually a representative from another group or division. On such projects the product owner and customer roles are often combined. For a commercially distributed product, the customer will be the person who buys the software. In either case, the customer may or may not be a user of the software, which is, of course, another important role. (Raphael!)

Another role worth highlighting is that of developer. I use developer very generally to refer to anyone developing software. That includes programmers, testers, analysts, database engineers, usability experts, technical writers, architects, designers, and so on. Using this definition, even the product owner may be thought of as a developer on many projects. (Us!)

A final role is the project manager. As described by Highsmith (2004), the role of the project manager changes on agile projects. Agile project managers focus more on leadership than on management. On some agile projects, the person fufilling the project manager role will also act in another role, often as a developer but occasionally as a product owner. (Felix!)

* Work in short iterations

On an agile project there is no grand delineation of phases—no upfront requirements phase followed by analysis followed by architectural design and so on. Depending upon the actual agile process you select or define, you may put a very short design, modeling, or other phase at the front end of the project. But, once the project has begun in earnest, all work (requirements, design, coding, testing, and so on) happens concurrently within each iteration.

Iterations are timeboxed, meaning they finish on time even if functionality is dropped to do so, and are often very short. Most agile teams work in iterations of from one to four weeks long but some teams maintain their agility with iterations of up to three months. Most teams settle upon a relatively consistent iteration length. Some, however, choose the appropriate length for an iteration at the start of each iteration.

* Deliver something each iteration

More crucial than the specific iteration length chosen by a team is that during the iteration they transfrom one or more imprecise requirements statements into coded, tested, and potentially shippable software. Of course many teams will not deliver the results of every iteration to their users; the goal is simply that they could. This means that teams make progress by adding one or more small features in each iteration but that each added feature is coded, tested, and of releaseable quality.

It is essential that the product be brought to this potentially shippable state by the end of each iteration. Practically, this does not mean a team must do absolutely everything necessary to release since they often won’t release each iteration. For example, I work with one team that requires two months of mean time between failure (MTBF) testing before releasing their product, which includes both hardware and software. They cannot shorten those two months as it is contractually required by their client and that amount of time is often necessary to check for hardware failures. This team works in four-week iterations and apart from running this two-month MTBF test, their product is at a truly releasable state at the end of each iteration.

Because a single iteration does not usually provide sufficient time to complete enough new functionality to satisfy user or customer desires, the broader concept of a release is introduced. A release comprises one or more (usually more) iterations that build upon each other to complete a set of related functionality. While iterations are most commonly one to four weeks, a release is typically two to six months. For example, in an investment management system, one release may include all of the functionality related to buying and selling mutual funds and money market funds. This may take six two-week iterations to complete (roughly three months). A second release may add stock and bond trading and take four additional two-week iterations. Releases may occur at varying intervals. A first release may take six months to be developed. It may be followed by another release three months later, and so on.

* Focus on business priorities

Agile teams demonstrate a commitment to business priorities in two ways. First, they deliver features in the order specified by the product owner, who is expected to prioritize and combine features into a release that optimizes the return on the organization’s investment in the project. To achieve this, a release plan is created based on the team’s capabilities and a prioritized list of desired new features. In order for the product owner to have the most flexibility in prioritizing, features must be written so as to minimize the technical dependencies between them. It is difficult for a product owner to prioritize features into a release plan if the selection of one feature requires the prior development of three others. A team is unlikely to achieve a goal of absolutely no dependencies; however, keeping dependencies at a minimum is often quite feasible.

Second, agile teams focus on completing and delivering user-valued features rather than on completing isolated tasks (that eventually combine into a user-valued feature). One of the best ways to do this is to work with user stories, which are a lightweight technique for expressing software requirements. A user story is a brief description of functionality as viewed by a user or customer of the system. User stories are free-form and there is no mandatory syntax. However, it can be useful to think of a story generally fitting the form: “As a <type of user>, I want <capability> so that <business value>.” With this template as an example, you may have the story “As a book-buyer, I want to search for a book by ISBN so that I can find the right book quickly.”

User stories are lightweight because the work to gather and document them is not all done upfront. Rather than writing a lengthy requirements specification, agile teams have found it better to pursue to a just-in-time requirements approach. Typically this begins with a short description of a user story being handwritten on a note card, or perhaps typed into a computer for larger or distributed teams. The story card is just the beginning, though, and each user story is accompanied by as many conversations between the developers and the product owner as needed. These conversations happen as often as needed and include whoever is necessary. Written documentation may continue to exist when using a story-based requirements approach. However, the focus is shifted dramatically from written to verbal communication.

* Inspect and adapt

The plan created at the start of any project is not a guarantee of what will occur.  In fact, it is only a point-in-time guess. Many things will conspire to invalidate the plan — project personnel may come or go, technologies will work better or worse than expected, users will change their minds, competitors may force us to respond differently or more rapidly, and so on. Agile teams view every such change as presenting both the opportunity and need to update the plan in order to better reflect the reality of the current situation.

At the start of each new iteration, an agile team incorporates all new knowledge gained in the preceding iteration and adapts accordingly. If a team has learned something that is likely to affect the accuracy or value of the plan, they adjust the plan. The accuracy of the plan may be affected by the team discovering they have over- or underestimated their rate of progress. Or they may discover that a certain type of work is more time-consuming than previously thought.

The value of the plan may be altered by knowledge the product owner has gained about the desires of likely users. Perhaps, based on feedback from seeing the software from an earlier iteration, the product owner has learned that users would like to see more of one type of feature and that they don’t value another feature as much as was previously thought. The value of the plan could be increased in this case by moving more of the desired features into the release at the expense of some of the lesser-valued features.

None of this is to say that agile teams take an ad hoc view of changing priorities. Priorities do tend to be relatively stable from one iteration to the next.  However, the opportunity to alter priorities between iterations is a powerful contributor to the ability to maximize the return on the project investment.


An Agile Approach to Planning
-----------------------------

Estimating and planning the development of a new product is a daunting task made more difficult by our misconceptions about projects. Macomber (2004) points out that we should not view a project solely as the execution of a series of steps. Instead, it is important that we view a project as rapidly and reliably generating a flow of useful new capabilities and new knowledge. The new capabilities are delivered in the product, the new knowledge is used to make the product the best that it can be.

On an agile project, we use this flow of new capabilities and knowledge to guide the ongoing work. The new knowledge generated by the project may be about the product or the project. New product knowledge helps us know more about what the product should be. New project knowledge is information about the team, the technologies in use, the risks, and so on.

We frequently fail to acknowledge and plan for this new knowledge. Failing to plan to acquire new knowledge leads to plans built on the assumption that we know everything necessary to create an accurate plan. In the world of software development that is rarely, if ever, the case. Ward Cunningham has said that “it’s more planning what you want to learn, not what it [the product] will be in the end.” (Van Schooenderwoert 2004).

I often equate the traditional view of a project as running a 10-kilometer race. You know exactly how far away the finish line is and your goal is to reach it as quickly as possible. On an an agile project, we don’t know exactly where the finish line is but we often know we need to get to it or as close as we can by a known date. An agile project is more like a timed race than a 10-kilometer race: run as far as possible in sixty minutes. In this way, the agile project team knows when it will finish, but not what they will deliver. When we acknowledge that the end result is both somewhat unknown as well as unknowable in advance, plan- ning becomes a process of setting and revising goals that lead to a longer term objective.

* Multiple Levels of Planning

When setting and revising goals, it is important to remember that we cannot see past the horizon and that the accuracy of a plan decreases rapidly the further we attempt to plan beyond where we can see. For example, suppose you are standing on a small boat and that your eyes are nine feet above the water. The distance to the horizon in this case is slightly over four miles.1 If you are planning a twenty mile trip, you should plan on looking ahead at least five times, once every four miles. Because you cannot see past the horizon, you need to look up often and adjust your plan. A project is at risk if its planning extends well beyond the planner’s horizon and does not include time for the planner to raise her head, look at the new horizon, and make adjustments. A progressive elaboration of the plan is needed.

Agile teams achieve this by planning at three distinct horizons. The three horizons are the release, the iteration, and the current day. The relationships between these (and other) planning horizons can be seen in the planning onion of Figure below:

       Strategy
       Portfolio
       Product
-----  Release  -----
| --- Iteration --- |
| | ---- Day ---- | |
| | |           | | |
| | |           | | |
| | ------------- | |
- -------------------

Most agile teams are only concerned with the three innermost levels of the planning onion. Release planning considers the user stories or themes that will be developed for a new release of a product or system. The goal of release planning is to determine an appropriate answer to the questions of scope, schedule, and resources for a project. Release planning occurs at the start of a project but is not an isolated effort. A good release plan is updated throughout the project (usually at the start of each iteration) so that it always reflects the current expectations about what will be included in the release.

At the next level is iteration planning, which is conducted at the start of each iteration. Based on the work accomplished in the just-finished iteration, the product owner identifies high priority work the team should address in the new iteration. Because we are looking at a closer horizon than with release planning, the components of the plan can be smaller. During iteration planning we talk about the tasks that will be needed to transform a feature request into working and tested software.

Finally, there is daily planning. Most agile teams use some form of daily standup meeting to coordinate work and synchronize daily efforts. Although it may seem excessive to consider this planning in the formal sense, teams definitely make, assess, and revise their plans during these meetings. During their daily meetings, teams constrain the planning horizon to be no further away than the next day, when they will meet again. Because of this, they focus on the planning of tasks and on coordinating the individual activities that lead up to the completion of a task.

Outside the concern of most individual agile teams (and this book) are product, portfolio, and strategic planning. Product planning involves a product owner looking further ahead than the immediate release and planning for the evolution of the released product or system. Portfolio planning involves the selection of the products that will best implement a vision established through an organization’s strategic planning.

* Conditions of Satisfaction

Every project is initiated with a set of objectives. Your current project may be to create the world’s best word processor. Creating the world’s best word processor, however, will typically be only one objective for this project. There will almost certainly be additional objectives regarding schedule, budget, and quality. These objectives can be thought of as the the customer or product owner’s conditions of satisfaction; that is, the criteria that will be used to gauge the success of the project.

Way back when I was a high school and assigned to write a paper about a book such as Moby Dick I would always ask the teacher how long the paper had to be. She’d respond something like “five pages” and I then knew her primary condition of satisfaction. There were, of course, a number of additional, unwritten conditions of satisfaction such as that the paper would be well-written, my own work, in English, and so on.

At the start of release planning, the team and product owner collaboratively explore the product owner’s conditions of satisfaction. Common factors in her conditions of satisfaction include the usual items: scope, schedule, budget, and quality, although agile teams typically prefer to treat quality as non-negotiable.  The team and product owner look for ways to meet all of the conditions of satisfaction. The product owner may, for example, be equally satisfied with a release in five months that includes one set of user stories as with a release a month later that includes additonal user stories.

Sometimes, however, all of the product owner’s conditions of satisfaction cannot be met. The team can build her the world’s best word processor but they cannot build it by next month. When no feasible solution can be found, the conditions of satisfaction must change. Because of this, release planning and exploration of the product owner’s conditions of satisfaction are highly iterative.

Once a release plan covering approximately the next three to six months is established, it is used as input into the planning of the first iteration. Just as release planning began with consideration of the product owner’s conditions of satisfaction, so does iteration planning. For an iteration, the product owner’s conditions of satisfaction are typically the features she’d like developed next and some high-level tests about each feature.

As an example, consider a travel reservation site that includes the user story, “As a user, I want to be able to cancel a reservation.” In discussing this story with the product owner, the developers learn that her conditions of satisfaction for this story include that:

  A user who cancels more than 24 hours in advance gets a complete refund
  A user who cancels less than 24 hours in advance is refunded all but a $25 cancellation fee
  A cancellation code is displayed on the site and is emailed to the user

Like release planning, iteration planning is iterative. The product owner and the team discuss various ways of best meeting the conditions of satisfaction for the iteration.

Feedback loops from the resulting new product increment back into the conditions of satisfaction boxes at the start of both release and iteration planning. Based on their experience developing the product increment during the iteration the team may have gained knowledge or experience that affects planning at one or more of these levels. Similarly, showing the product increment to existing or likely users may generate new knowledge that may cause changes to the plans. An agile team will incorporate these changes into their plans to the extent they lead to a higher-value product.


========================
Part II. Estimating Size
========================

Agile teams separate estimates of size from estimates of duration. Estimates size first, then estimate duration. (Duration = Size/Velocity) We'll see two measures of size - story points and ideal time.


4. Estimating Size with Story Points
====================================


Story Points are Relative
-------------------------

Story points are a unit of measure for expressing the overall size of a user story, feature, or other piece of work. When we estimate with story points we assign a point value to each item. The raw value we assign is unimportant. What matters are the relative values. A story that is assigned a two should be twice as much as a story that is assigned a one. It should also be two-thirds of a story that is estimated as three story points.

The number of story points associated with a story represents the overall size of the story. There is no set formula for defining the size of a story. Rather, a story point estimate is an amalgamation of the amount of effort involved in developing the feature, the complexity of developing it, the risk inherent in it, and so on.

There are two common ways to get started. The first appoach is to select a story that you expect to be one of the smallest stories you’ll work with and say that story is estimated at 1 story point. The second approach is instead to select a story that seems somewhat medium-sized and give it a number somewhere in the middle of the range you expect to use. Personally, I prefer most of my stories to be in the range of 1–10. This means I’ll look for a medium-size story and call it five story points. Once you’ve fairly arbitrarily assigned a story point value to the first story, each additional story is estimated by comparing it to the first story or to any others that have been estimated.

On an agile project it is not uncommon to begin an iteration with incompletely specified requirements, the details of which will be discovered during the iteration. However, we need to associate an estimate with each story, even those that are incompletely defined. When you’re given a loosely-defined user story (or dog), you make some assumptions, take a guess, and move on. You can guess like this: "this won't be larger than A, which is 5 points; and will be larger than B, which 1-2 points. So give it an average, 3, will be reasonable"


Velocity
--------

In order to understand how estimating in unitless story points can possibly work, it is necessary to introduce a new concept: velocity. Velocity is a measure of a team’s rate of progress. It is calculated by summing the number of story points assigned to each user story that the team completed during the iteration. If the team completed three stories each estimated at five story points then their velocity would be fifteen. If the team completed two five-point stories their velocity would be ten.

If a team completed ten story points of work last iteration, our best guess is that they will complete ten story points this iteration. Since story points are estimates of relative size, this will be true whether they work on two five-point stories or five two-point stories. If we sum the story point estimates for all desired features we come up with a total size estimate for the project. If we know the team’s velocity we can divide size by velocity to arrive at an estimated number of iterations. We can turn this duration into a schedule by mapping it onto a calendar.

Fortunately, as a team begins making progress through the user stories of a project, their velocity becomes apparent over the first few iterations. The beauty of a points-based approach to estimating is that planning errors are self-correcting because of the application of velocity. The beauty of this is that estimating in story points completely separates the estimation of effort from the estimation of duration. Of course effort and schedule are related, but separating them allows each to be estimated independently. In fact you are no longer even estimating the duration of a project; you are computing it or deriving it. The distinction is subtle but important.


5. Estimating in Ideal Days
===========================

Ideal time is the amount of time that something takes when stripped of all peripheral activities. Elapsed time, on the other hand, is the amount of time that passes on a clock (or perhaps a calendar). It is almost always far easier and accurate to predict the duration of an event in ideal time than in elapsed time. 

On a software project, ideal time differs from elapsed time because of the natural overhead we experience every day. On any given day, in addition to working on the planned activities of a project, a team member may spend time answering email, making a support call to a vendor, interviewing a candidate for the open analyst position, and in two meetings. 

Additionally, in looking at why ideal time does not equal elapsed time, consider that managers are able to work an average of only five minutes between interruptions (Hobbs 1987). Even if the typical developer is interrupted only one-third as often that is still an interruption every fifteen minutes.

Problems can arise when a manager asks a team member the inevitable question: “How long will this take?” The team member responds “five days,” so the manager counts off five days on her calendar and marks the day with a big red X. The team member, however, really meant to say, “Five days if that’s all I do; but I do a lot of other things so probably two weeks.” On a software project, multitasking also broadens the gap between ideal time and elapsed time. A football player is never asked by his coach, “Since you’re not busy on every play, I want you to play in this high-priority hockey game at the same time.” A software developer who is told to multitask loses a great deal of efficiency while switching between two (or more) tasks.

On a software project, we may choose to estimate user stories or other work in ideal days. When estimating in ideal days you assume that:

  * the story being estimated is the only thing you’ll work on (single task)
  * everything you need will be on hand when you start (independent)
  * there will be no interruptions


When we estimate the number of ideal days that a user story will take to develop, test, and accept, it is not necessary to consider the impact of the overhead of the environment in which the team works. If developing a particular screen will take me one ideal day, then it will take me one ideal day regardless of whether I’m employed by a startup with no overhead or other demands on my team or by a huge bureaucracy. 

*** When considerations of organizational overhead are ignored, ideal days can be thought of as another estimate of size, just as story points are. Then, an estimate of size expressed as a number of ideal days can be converted into an estimate of duration using velocity in exactly the same way as with story points.  

If you choose to estimate in ideal days, assign one aggregate estimate to each user story. Some teams are tempted to estimate a number of ideal days for each individual or group who will work on a story. For example, such a team might estimate that a particular user story will take two ideal days from a programmer, one ideal day from a database engineer, one ideal day from a user interaction designer, and two ideal days from a tester. I’ve seen teams then write the estimate on the story card with either a different colored marker for each role or on a different colored sticky piece of paper for each role that is affixed to the story card.

In the vast majority of cases my advice is not to do this. This level of focus on the individual roles on a team shifts team thinking away from the “we’re all in this together” mentality we’d like to exist on an agile team. Further, it vastly increases the amount of work necessary to plan a release. If each story is assigned an estimate for each role who will work on the story then the release plan should realistically take each role into account. This means we’d have to track velocity and remaining work for each role as well.

While this is rarely worth the additional effort it may sometimes be necessary. I was with one client recently who is working on three versions of a product — one for the Macintosh, one for Windows, and one for handheld computers. In their case it is absolutely critical that each version be released with exactly the same functionality. Further, the individuals on this team do not currently have the skills to switch between Mac, Windows, and handheld development. A team in this situation may want to estimate the ideal time for each role on each story. They should, however, be aware of the extra administrative burden this will require.


6. Techniques for Estimating
============================

No matter how much effort is invested, the estimate is never at the top of the accuracy axis. No matter how much effort you put into an estimate, an estimate is still an estimate. No amount of additional effort will make an estimate perfect. It is possible to put too much effort into estimating with the result being a less accurate estimate.

Agile team acknowledge that we cannot eliminate uncertainty from estimates but they embrace the idea that small efforts are rewarded with big gains. Even though they are less far up the accuracy/effort scale, agile teams can produce more reliable plans because they deliver small increments of fully working, tested, integrated code.


Estimates are Shared
--------------------

Estimates are not created by a single individual on the team. Agile teams do not rely on a single expert to estimate. Despite well-known evidence that estimates prepared by those who will do the work are better than estimates prepared by anyone else (Lederer 1992), estimates are best derived collaboratively by the team, which includes those who will do the work.

First, on an agile project we tend not to know specifically who will perform a given task. Yes, we may all suspect that the team’s database guru will be the one to do the complex stored procedure task that has been identified. However, there’s no guarantee that this will be the case. She may be busy when the time comes and someone else will work on it. So, since anyone may work on anything, it is important that everyone have input into the estimate.

Second, even though we may expect the database guru to do the work, others may have something to say about her estimate. Suppose, for example, that the team’s database guru, Kristy, estimates a particular user story as three ideal days. Someone else on the project may not know enough to program the feature himself but he may know enough to say, “Kristy, you’re nuts; the last time you worked on a feature like that it took a lot longer. I think you’re forgetting how hard it was last time.” At that point Kristy may offer a good explanation of why it’s different this time. However, more often than not in my experience, she will acknowledge that she was indeed underestimating the feature.


The Estimation Scale
--------------------

Studies have shown that we are best at estimating things that fall within one order of magnitude (Miranda 2001; Saaty 1996). So you're good at esimating disance between your home and nearest shopping-mall, but not good at the distance between your home and the Moon.

Two good estimation scales:

  * 1, 2, 3, 5, 8 (fibonacci)
  * 1, 2, 4, 8 (exponetial)

These non-linear sequences work well because they reflect the greater uncertainty associated with estimates for larger units of work. Each of these numbers should be thought of as a bucket into which items of the appropriate size are poured. Rather than thinking of work as water being poured into the buckets, think of the work as sand. 

You may want to consider including 0 as a valid number within your estimation range. While it’s unlikely that a team will encounter many user stories or features that truly take no work, including 0 is often useful. There are two reasons for this. First, if we want to keep all features within a 10x range, assigning non-zero values to tiny features will limit the size of largest features. Second, if the work truly is closer to 0 than 1, the team may not want the completion of the feature to contribute to its velocity calculations. 

While, in general, we want to estimate user stories whose sizes are within one order of magnitude, this cannot always be the case. If we are to estimate everything within one order of magnitude it would mean writing all stories at a fairly fine-grained level. For features that we’re not sure we want (a preliminary cost estimate is desired before too much investment is put into them) or for features that may not happen in the near future, it is often desirable to write one much larger user story. A large user story is sometimes called an epic.

Additionally, a set of related user stories may be combined together (usually by a paper clip if working with note cards) and treated as a single entity for either estimating or release planning. Such a set of user stories is referred to as a theme. An epic, by its very size alone, is often a theme on its own. By aggregating some stories into themes and writing some stories as epics, a team is able to reduce the effort they’ll spend on estimating. However, it’s important that they realize that estimates of themes and epics will be more uncertain than estimates of the more specific, smaller user stories.

User stories that will be worked on in the near future (the next few iterations) need to be small enough that they can be completed in a single iteration. These items should be estimated within one order of magnitude. I use the sequence 1, 2, 3, 5, and 8 for this. User stories or other items that are likely to be more distant than a few iterations can be left as epics or themes. These items can be estimated in units beyond the 1–8 range I recommend. To accommodate estimating these larger items I add 13, 20, 40, and 100 to my preferred sequence of 1, 2, 3, 5, and 8.


Deriving an Estimate
--------------------

Three most common techniques may be used on its own but should be combined for best results when estimaing:

* Expert opinion

Ask an expert, and the expert gives an estimate based on his intuition. This approach is less useful on agile projects than on traditional projects. On an agile project, estimates are assigned to user stories or other user-valued functionality. Developing this functionality is likely to require a variety of skills normally performed by more than one person. This makes it difficult to find suitable experts who can assess the effort across all disciplines. On a traditional project for which estimates are associated with tasks this is not as significant of a problem because each task is likely performed by one person. Another benefit of this method is it's usually fast.

* Analogy

When estimating by analogy, the estimator compares the story being estimated to one or more other stories. If the story is twice the size, it is given an estimate twice as large. There is evidence that we are better at estimating relative size than we are at estimating absolute size.

When estimating this way you do not compare all stories against a single baseline or universal reference. Instead, you want to estimate each new story against an assortment of those that have already been estimated. This is referred to as triangulation. To triangulate, compare the story being estimated against a couple of other stories. To decide if a story should be estimated at five story points, see if it seems a little bigger than a story you estimated at three and a little smaller than a story you estimated at eight.

* Disaggregation

Disaggregation refers to splitting a story or feature into smaller, easier-to-estimate pieces.


Planning Poker
--------------

Planning poker combines expert opinion, analogy, and disaggregation into an enjoyable approach to estimating that results in quick but reliable estimates. Participants in planning poker include all of the developers on the team. The product owner participates in planning poker but does not estimate.

At the start of planning poker, each estimator is given a deck of cards. Each card has written on it one of the valid estimates. Each estimator may, for example, be given a deck of cards that read 0, 1, 2, 3, 5, 8, 13, 20, 40, and 100. The cards should be prepared prior to the planning poker meeting and the numbers should be large enough to see across a table. Cards can be saved and used for the next planning poker session. For each user story or theme to be estimated, a moderator reads the description. The moderator is usually the product owner or an analyst. However, the moderator can be anyone as there is no special privilege associated with the role. The product owner answers any questions that the estimators have. However, everyone is asked to remain aware of the effort/accuracy curve. The goal in planning poker is not to derive an estimate that will withstand all future scrutiny. Rather, the goal is to be somewhere well on the left of the effort line where a valuable estimate can be arrived at cheaply. After their questions are answered, each estimator privately selects a card representing his or her estimate. Cards are not shown until each estimator has made a selection. At that time, all cards are simultaneously turned over and shown so that all participants can see each estimate. It is very likely at this point that the estimates will differ significantly. This is actually good news. If estimates differ, the high and low estimators explain their estimates. It’s important that this does not come across as attacking those estimators. Instead, you want to learn what they were thinking about.

The group can discuss the story and their estimates for a few more minutes. The moderator can take any notes she thinks will be helpful when theis story is being programmed and tested. After the discussion, each estimator re-estimates by again selecting a card. Cards are once again kept private until everyone has estimated at which point they are turned over at the same time. In many cases, the estimates will already converge by the second round. But, if they have not, continue to repeat the process. The goal is for the estimators to converge on a single estimate that can be used for the story. It rarely takes more than three rounds but continue the process as long as estimates are moving closer together. It isn’t necessary that everyone in the room turn over a card with exactly the same estimate written down. If I’m moderating an estimate and on the second round four estimators tell me 5, 5, 5, and 3, I will ask the low estimator if she is OK with an estimate of 5. Again, the point is not absolute precision but reasonableness.

It is possible to play planning poker with a subset of the team, rather than involving everyone. This isn’t ideal but may be a reasonable option, especially if there are many, many items to be estimated as can happen at the start of a new project. The best way to do this is to split the larger team into two or three smaller teams each of which must have at least three estimators. It is important that each of the teams estimate consistently. What your team calls three story points or ideal days better be consistent with what my team calls the same. To achieve this, start all teams together in a joint planning poker game for an hour or so. Have them estimate 10–20 stories. Then make sure each team has a copy of these stories and their estimates and that they use them as baselines for estimating the stories they are given to estimate.

Teams will need to play planning poker at two different times. First, there will usually be an effort to estimate a large number of items before the project officially begins or during its first iterations. To estimate an initial set of user stories may take a team two or three meetings of from one to three hours. Naturally this will depend on how many items there are to estimate, the size of the team, and the product owner’s ability to succinctly clarify the requirements. Second, teams will need to put forth some ongoing effort to estimate any new stories that are identified during an iteration. One way to do this is to plan to hold a very short estimation meeting near the end of each iteration. Normally this is quite sufficient for estimating any work that came in during the iteration and it allows new work to be considered in the prioritization of the coming iteration.

Alternatively, colleague Kent Beck suggests hanging an envelope on the wall with all new stories placed in the envelope. As individuals have a few spare minutes they will grab a story or two from the envelope and estimate them. Teams will establish a rule for themselves, typically either that all stories must be estimated by the end of the day or by the end of the iteration. I like the idea of hanging an envelope on the wall to contain unestimated stories. However, I’d prefer that when someone has a few spare minutes to devote to estimating that he find at least one other person and that they estimate jointly.

* Planning poker brings together multiple expert opinions to do the estimating.
* A lively dialogue ensues during planning poker and estimators are called upon by their to justify their estimates. 
* Studies have shown that averaging individual estimates leads to better results as do group discussions of estimates.
* Planning poker works because it’s fun.


7. Re-Estimating
================

If we keep in mind that story points and ideal time estimate size then it’s easier to see that we should re-estimate only when we believe a story’s relative size has changed. When working with story points or ideal time we do not re-estimate solely because a story took longer to implement than we thought.

Velocity is the great equalizer. Because the estimate for each feature is made relative to the estimates for other features, it does not matter if our estimates are correct, a little incorrect, or a lot incorrect. What matters is that they are consistent.

I’m generally in favor of an all-or-nothing stance toward counting velocity: if a story is done (coded, tested, and accepted by the product owner) then the team earns all the points, but if anything on the story isn’t done, they earn nothing. At the end of an iteration, this is the easiest case to assess. This works well as long as everyone remembers that we’re mostly interested in the team’s average velocity over time, not in whether velocity jumped up or down in a given iteration.

In some cases the unfinished portion of a story may not be done in the next iteration. In these cases it can be appropriate to allow the team to take partial credit for the completed portion of the story. The remaining story (which is a subset of the initial story) is re-estimated based on the team’s current knowledge. 

Do not become overly concerned with the need to re-estimate. Whenever the team feels one or more stories are mis-estimated relative to other stories, re-estimate as few stories as possible to bring the relative estimates back in line.


8. Choosing Between Story Points and Ideal Days
===============================================

Why Story Points
----------------

* Story points help drive cross-functional behavior

* Story point estimates do not decay

  Note that both story point and ideal day estimates will need to be updated if the size of an effort changes based on the development of a framework, for example. However, only ideal day estimates need to change when the team the team becomes better at something. Velocity won't fix the problem with ideal days.

* Story points are a pure measure of size

  First, this means that we can only estimate story points by analogy. There is credible evidence that we are better at estimating “this is like that” than we are at estimating the absolute size of things (Lederer 1998; Vicinanza 1991). When we estimate in ideal days, on the other hand, we can still estimate by analogy. But, when estimating in ideal days we also tend to think of the calendar and how long a story will take to develop.

  Second, because story points are a pure measure of size and are entirely abstract there can be no temptation to compare them to reality. Teams that estimate in ideal days almost inevitably have their ideal days compared to actual days. They then find themselves justifying why they “only” completed eight ideal days of work in a ten-day iteration.

* Estimating in story points is typically faster

* My ideal days are not your ideal days


Why Ideal Days
--------------

* Ideal days are easier to explain outside the team

* Ideal days are easier to estimate at first

* Ideal days make velocity predictions easier


============================
Part III. Planning for Value
============================


9. Prioritizing Themes
======================

The responsibility for prioritizing is shared among the whole team but the effort is led by the product owner.

It is generally difficult to estimate the value of small units of functionality, such as a single user story. To get around this, individual user stories or features are aggregated into themes. Stories and themes are then prioritized relative to one another for the purpose of creating a release plan. Themes should be selected such that each defines a discrete set of user- or customer-valued functionality. 


Factors in Prioritization
-------------------------

1. The financial value of having the features

   Often, an ideal way to determine the value of a theme is estimate its financial impact over a period of time, usually the next few months, quarters, or possibly years. Because of the complexity in doing this, it is often useful to have an alternate method for estimating value. Since the value of a theme is related to the desirability of that theme to new and existing users, it is possible to use non-financial measures of desirability to represent value. 
                        
2. The cost of developing (and perhaps supporting) the new features

   An important, yet often overlooked, aspect of cost is that the cost can change over time. The best way to reduce the cost of change is to implement a feature as late as possible - effectively when there is no more time for change.

   Themes often seem worthwhile when viewed only in terms of the time they will take. As trite as it sounds, it is important to remember that time costs money. We can turn story points into money by:  $x/point = total expense on project/total story points. Then convert points esitmate on story into money estimate, and ask yourself: will this story worth that much investment?

3. The amount and significance of learning and new knowledge created by developing the features

   On many projects, much of the the overall effort is spent in the pursuit of new knowledge. It is important that this effort be acknowledged and considered fundamental to the project. Acquiring new knowledge is important because at the start of a project we never know everything that we’ll need to know by the end of the project. The knowledge that a team develops can be classified into two areas:

   * Knowledge about the product: knowledge about what will be developed. The more product knowledge a team has, the better able they will be to make decisions about the nature and features of the product.  

   * Knowledge about the project: knowledge about how the product will be created, include what technologies will be used.

The flip side of acquiring knowledge is reducing uncertainty. At the start of a project there is some amount of uncertainty about what features the new product should contain. There is also uncertainty about how we’ll build the product. Laufer (1996) refers to these as end uncertainty and means uncertainty. End uncertainty is reduced by acquiring more knowledge about the prodcut; means uncertainty is reduced through acquiring more knowledge about the project.

4. The amount of risk removed by developing the features

   Risks can be classified as either technological or business risks. To optimally prioritize work it is important to consider both risk and value.  

   The appropriate development sequence for the features is high-value-high-risk -> high-value-low-risk -> low-value-low-risk, and low-value-high-risk feature should be avoid.

   The high-value, high-risk features should be developed first. These features deliver the most value and working on them eliminates significant risks. Next are the high-value, low-risk features. These features offer as much value as the first set but they are less risky. They can therefore be done later in the schedule. Because of this, use the guideline to work first on high-value features but use risk as a tie-breaker.

   Be aware that a feature’s risk and value profile changes over time. 

Because most projects are undertaken to either save or make money, the first two factors often dominate prioritization discussions. However, proper consideration of the influence of learning and risk on the project is critical if we are to prioritize optimally.

To combine the four prioritiziaton factors, think first about the value of the feature relative to what it would cost to develop today. This gives you an initial priority order for the themes. Those themes with a high value-to-cost ratio are those that should be done first. Next, think of the other prioritization factors as moving themes forward or backward. 


10. Financial Prioritization
============================

Calculating
-----------

Forecasting the financial value of a theme is the responsibility of the product owner but it is a responsibility shared with all other team members. The way I like to determine the financial value of a theme is to hold a meeting (or serveral meeting) attended by as many of these individuals as practical, to generate a table for each theme like this:

------------------------------------------------------------------------------------------------
Quarter   | New Revenue   | Incremental Revenue   | Retained Revenue  | Operational Efficiencies
------------------------------------------------------------------------------------------------

The return on a project can come from a variety of sources. For convenience, we can categorize these into new revenue, incremental revenue, retained revenue, and operational efficiencies. While it is common for one category to dominate the return of a specific project, most projects will earn returns from more than one category.

* New revenue is revenue from new users.
* Incremental revenue is that from existing users.
* Retained revenue is the revenue an organization will lose if the project is not performed.
* Operational Efficiencies: No organization is ever as efficient as it could be. There’s always some task that could be streamlined or eliminated altogether. If you’re developing software for use by internal customers you are probably quite aware of the importance of operational efficiencies. However, even if you’re working on commercial software that is sold to others outside your company, some tasks within your project may still contribute to improving operational efficiencies. In your case, though, most often this will refer to your own inefficiency. e.g. anything that takes a long time or that would take a long time if the company grew, better integration or communciation between departments, reduced employee turnover, shorter training time for new employees, any time-sensitive process, combining multiple processes, anything that improves accuracy and reduces rework

(The categories here are only suggestions. You should change them if they're not appropriate for your project.)

The table includes a row for each quarter in the next two years. The time-frame is up to the team. In some cases, teams may want to look at monthly returns for one or two years. In other cases, quarterly forecasts are adequate. I find that looking out two years works well on most projects. It strikes a good balance between guessing at the distant future and looking far enough ahead. Because of the high amount of uncertainty on software development projects, others concur (Bills 2004).

The table also includes columns for various types of return a theme may have. If your project has different types of returns, use different column headings. Similarly, use different column headings if a theme will benefit from more specific column headings (perhaps “Increased Revenue from U.S. customers” and “Increased Revenue for European customers”). It is not necessary to estimate all themes with the same set of columns.

Where do these numbers we can fill in the table come from? Hopefully from some market research that was used in the business case that initiated the project. At a minimum, who ever is requesting the theme should be able to quantify the reasons for developing it.

We also need to estimate the expected development cost of the theme:

---------------------------------------------------------------------------------------------------------------------------------------
Role  | Annual Salary   | Fully Burdened Labor Cost   | Burdened Cost Per Iteration   | Time on Project   | Adjusted Cost Per Iteration
---------------------------------------------------------------------------------------------------------------------------------------

It is often useful to know the cost per story point (or ideal day). To calculate this, divide the adjusted cost per iteration by the team’s average or expected velocity.

Finally we put the two tables together:

-------------------------------------------------------------------------------------------------------------------------------------
Quarter   | Development Cost  | New Revenue   | Incremental Revenue   | Retained Revenue  | Operational Efficiencies  | Net Cash Flow
-------------------------------------------------------------------------------------------------------------------------------------


The Time Value of Money
-----------------------

Money today is more valuable than money next Tuesday. ROI (return on investment) calculations put equal value on the money invested in year one and the money earned in year five, which is a problem. To determine the value today of a future amount of money, we think in terms of how much money would have to be put in the bank today in order for it grow to the future amount. To buy a ¤5 hamburger next Tuesday, I might need to put ¤4.99 in the bank today. The amount I have to invest today in order to have a known amount in the future is called the present value. As a simple case, if I can earn 10% on my money and want to have ¤1.00 a year from now, I need to invest ¤0.91 today. In other words, with a 10% interest rate, ¤0.91 is the present value of ¤1.00 in a year.

The process of moving future amounts back into their present value is known as discounting. Clearly the interest rate that is used for discounting future amounts is critical to determining the present value of a future amount. The rate by which organizations discount future money is known as their opportunity cost, and reflects the percentage return that is passed up in order to make this investment. We all - individuals and organizations - have various opportunities for investing our money. I can put my money into a bank saving account or I can invest in stocks. I can invest it in real estate or I can put it under my mattress. Organizations can invest their money in these same ways or they can invest money on various projects. If an organization has typically earned 20% on past projects, new projects must be assessed against this same 20%. The organization’s opportunity cost is 20% because an investment in a new project means that the organization gave up the opportunity to invest in some other project, which would have earned 20%.


Measures
--------

Having come up with a way of estimating the cash flow stream that will be generated by each theme, we next turn our attention to various ways of analyzing and evaluating those cash flow streams.

* Net Present Value (NPV)

  NPV(i) = ∑(t=0,n).Ft*(1+i)^-t
  
  i is the interest rate, Ft is net cash flow in period t.

  Using Net Present Value to compare and prioritize themes has the advantages of being easy to calculate and easy to understand. The primary disadvantage to NPV is that comparing the values of two different cash flow streams can be misleading. For example, suppose we are trying to choose between two projects. The first project requires huge upfront investments but has an NPV of ¤100,000. The second project requires only a small upfront investment but also has an NPV of ¤100,000. Clearly we’d prefer to make the investment in the theme that ties up less cash but that has the same NPV. What we’d really like is to express the return on a theme in percentage terms so that we can directly compare themes.

* Internal Rate of Return (IRR, sometimes called Return On Investment, or ROI)

  IRR provides a way of expressing the return on a project in percentage terms. Where NPV is a measure of how much money a project can be expected to return (in today’s present value), IRR is a measure of how quickly the money invested in a project will increase in value. Many organizations will specify a minimum attractive rate of return or MARR. Only projects or themes with an IRR that exceeds the MARR will be funded. It is impractical to set a similar threshold for NPV since NPV values are highly dependent on the magnitude of the project. If an NPV threshold were in place then small (but valuable) projects would never be approved.

  IRR is defined as the interest rate at which the NPV of a cash flow stream is equal to 0. In other words, it is the value for i* such that:

  0 = PV(i*) = ∑(t=0,n).Ft*(1+i)^-t

  Note:
  - The first one or more items in the cash flow stream must be expenses. (Note that there must be at least one.)
  - Once the cash flow stream turns positive, it must remain positive.
  - The sum of the positive items is larger than the sum of the negative items. That is, money is made overall.

  A first advantage to using IRR is that there is no requirement to establish (or, in the worst case, guess at) an organization’s discount rate as is necessary when calculating NPV. A second advantage to IRR is that it can be used directly in comparing projects. A project with a 45% IRR has a higher return on its investment than does a project with a 25% IRR. You cannot usually use IRR in isolation, though, for making decisions. For example, suppose the project returning 45% is very small so the 45% return comes on a small investment yet the project ties up a critical developer. Further, suppose that the project returning 25% does so against a large investment but requires the same critical developer. You may choose to make more money by doing the second project, the one with the lower IRR.

  A first disadvantage to IRR is that because the calculation is hard to do by hand, the result may be more subject to distrust by some. A second disadvantage is that IRR cannot be calculated in all situations. As we saw above, three preconditions must be met in order to calculate a meaningful IRR.

* Payback period

  Payback period is the amount of time required to earn back the initial investment

  There are two primary advantages to using payback period when comparing and prioritizing themes. First, the calculations and interpretation are straight-forward. Second, it measures the amount and duration of financial risk taken on by the organization. The larger the payback period, the riskier the project because anything could change during that period.

  The primary disadvantage to payback period is that it fails to take into account the time value of money. Money received three years in the future is valued as highly as money paid out today. The second drawback to payback period is that it is not a measure of the profitability of a project or theme. Payback period will tell us that an organization will recover its money in seven quarters, but it doesn’t address how much money will be made.

* Discounted payback period

  It is easy to remedy the first drawback of the payback period calculation. To do so we simply apply the appropriate discount factor to each item in the cash flow stream.


Comparing Returns
-----------------

As you assess each theme, you build up information that can be used to compare the themes and make the prioritization decisions that are driving this analysis. The results of valuing multiple themes can be presented in a table like the one shown in table below. A table such as this lets an organization quickly and effectively review its options and choose to work on the highest-valued themes.

---------------------------------------------------------------------------
Theme   | Story Points  | Cost  | NPV   | ROI   | Discounted Payback Period
---------------------------------------------------------------------------

Making a decision is not cut and dry; the product owner and team will need to consider a variety of situationally-specific factors such as the organization’s tolerance for risk, need for short payback periods, availability of resources, other options for investment money, and so on.

For More on Project Economics: "Return on Software: Maximizing the Return On Your Software Investment", Steve Tockey, 2004.


11. Prioritizing Desirability
=============================

Kano Model of Customer Satisfaction
-----------------------------------

The process was originated by Noriaki Kano (1984). Kano’s approach gives us a way to separate features into three categories:

  * Threshold, or must-have, features

  Threshold features are those that must be present in the product for it to be successful. They are often referred to as must-have features. Improving the performance or amount of a threshold feature will have little impact on customer satisfaction.

  * Linear features

  A linear feature is one for which “the more, the better” holds true. The bigger the hotel room is, the better. These are called linear features because customer satisfaction is correlated linearly with the quantity of the feature. The better one of these features performs (or the more of it there is), the more satisfied the customers will be. Because of this, product price is often related to linear attributes.

  * Exciters and delighters

  Exciters and delighters are those features that provide great satisfaction, often adding a price premium to a product. However, the lack of an exciter or delighter will not decrease customer satisfaction below neutral. The built-in television on the hotel’s treadmill was an exciter for me. I would not have been dissatisfied if the hotel didn’t offer these because I didn’t know anyone had them. In fact, exciters and delighters are often called unknown needs because customers or users do not know they need these features until they see them.


Because must-have features are required for a product to even play in its market segment, emphasis should be placed on prioritizing the development of all threshold features. A product’s must-have features do not need to be developed in the first iterations of a release. However, since users consider these features as mandatory, they need to be available before the product is released. Keep in mind, though, that partial implementation of must-have features may be adequate since gains in customer satisfaction drop off quickly after a base level of support for threshold features has been established. 

Secondary emphasis should be placed on completing as many linear features as possible. Because each of these features leads directly to greater customer satisfaction, the more of these features that can be included, the better. (Excluding, of course, such situations as a product that is already bloated with too many features.) Finally and with time permitting, at least a few delighters should be prioritized such that they are included in the release plan.


The easiest way to make use of a Kano model on an agile project is to think about each theme and make an educated guess about the type of each. A much better way, however, is to speak with customers or users in order to truly determine the type of each theme. This is surprisingly easy because it can be done with a written questionnaire and you may need to survey as few as 20–30 users to accurately prioritize requirements.

Kano proposed determining the category of a feature by asking two questions: one question regarding how the user would feel if the feature were present in the product and one question about how the user would feel if it were absent. The answers to these questions are on the same five-point scale:

  1. I like it that way
  2. I expect it to be that way
  3. I am neutral
  4. I can live with it that way
  5. I dislike it that way

Answsers from one user can be inconsistent. By cross-referencing the answer to the functional question with the answer to the dysfunctional question, a prospective user’s responses can be reduced to a single meaning. We use the table:

Customer      | Dysfunctional Question
Requirements  | Like | Expect | Neutral | Live with | Dislike
-------------------------------------------------------------
F Q| Like     | Q    | E      | E       | E         | L
u u|--------------------------------------------------------- 
n e| Expect   | R    | I      | I       | I         | M
c s|--------------------------------------------------------- 
t t| Neutral  | R    | I      | I       | I         | M
i i|---------------------------------------------------------
o o| Live with| R    | I      | I       | I         | M
n n|---------------------------------------------------------
a  | Dislike  | R    | R      | R       | R         | Q
l  |---------------------------------------------------------

M   Must-have
R   Reverse
L   Linear
Q   Questionable
E   Exciter
I   Indifferent

If we repeat this process over 20–30 users their answers can be aggregated and their distributions determined as is shown in table below:

------------------------------------------------------
Theme   | E   | L   | M   | I   | R   | Q   | Category
------------------------------------------------------

Occasionally you’ll encounter a feature that has high values for two responses. This indicates that different types of customers and users have different expectations. In these cases you should consider analyzing responses based on some factor that differentiates your customer or user sub-population. You may, for example, separate answers from users at small companies from users at large companies. Or you may choose to separate answers based on job role within a company or by industry segment.


Relative Weighting
------------------

Karl Wiegers (1999) has recommended an approach that is similar to Kano’s in that considers both the positive benefit of the presence of a feature and the negative impact of its absence. Rather than use questionnaires, this approach relies on expert judgment. Collaboratively, but led by the product owner, the team assesses each feature being considered for the next release. Each feature is assessed in terms of the benefits it will bring if implemented as well as the penalty that will be incurred if it is not implemented. As with estimates of story points and ideal time, the estimates of benefits and penalties are relative. A scale of 1–9 is used. See table below:

--------------------------------------------------------------------------------------------------------------
Feature   | Relative Benefit  | Relative Penalty  | Total Value   | Value %   | Estimate  | Cost %  | Priority
--------------------------------------------------------------------------------------------------------------
...
--------------------------------------------------------------------------------------------------------------
Total     |                   |                   |               |           |           |         |
--------------------------------------------------------------------------------------------------------------


For each feature, the relative benefit and penalty are summed and entered into the Total Value column. If you wish, you could weight the benefits and penalties. For example, to weight the relative benefit as twice as important as the relative penalty, multiply the Relative Benefit by 2 before adding it to Relative Penalty to get the Total Value. The sum of the Total Value column represents the total value of delivering all features. To calculate the relative contribution of each feature, divide its total value by the sum of the Total Value column (fill it in Value % column).The Estimate holds the story point or ideal days estimate. Exactly as with Total Value, the Estimate column is summed and the percentage of each estimate is calculated in the Cost % column. The final column, Priority, is calculated by dividing the Priority % by the Cost %. Higher numbers represent higher priorities because they will create more value for the effort invested in them.


12. Splitting User Stories
==========================

When to Split A User Story:

* It is too large to fit within a single iteration. 
* A story may be small enough to fit within an iteration but it won’t fit within the iteration being planned because there isn’t enough room. The team may feel they will have time to develop a portion of a story in the iteration, but not the entire story.
* It can be useful to split a large user story (an epic) if a more accurate estimate is necessary. 


Splitting Tricks:

* Splitting Across Data Boundaries

  One of the best ways to split a large user story is by the data that will be supported. Like for a financial project, we can split an epic story "As a user I can enter my balance sheet information." into "As a user, I can enter summary balance sheet data.", "As a user, I can enter categorized balance sheet data.", "As a user, I can enter detailed loan informaton" and so on, since a balance sheet in this case could include a great many fields (at the highest level it includes assets and liabilities, assets included such items as cash, securities, real estate, automobiles, loans, and so on).

  In some cases a large story can be made much smaller by removing the handling of exceptional or error conditions from the main story. 

* Splitting On Operational Boundaries

  Split large stories based on the operations that are performed within the story. Like split a complicated search story into basic search, advanced search and so on. A common approach to doing this is to split a story along the boundaries of the common CRUD operations—Create, Read, Update, and Delete.

* Removing Cross-Cutting Concerns

  Consider removing cross-cutting concerns (such as security, logging, error handling, and so on) and creating two versions of the story: one with and one without support for the cross-cutting concern.

* Don't Meet Performance Constraints

  Considering splitting a large story by separating the functional and non-functional aspects into separate stories.

* Split Stories of Mixed Priority

* Don't Split A Story into Tasks

  The best way to avoid this temptation is to follow Hunt and Thomas’ advice (1999) to fire a tracer bullet through the system. A tracer bullet travels through all layers of a feature. That may mean delivering a partial user interface, a partial middle tier, and a partial database. Delivering a cohesive subset of all layers of a feature is almost always better than delivering all of one layer. This leads to another guidline: Don’t split a large story into tasks. Instead, try to find a way to fire a tracer bullet through the story.

* Avoid The Temptation of Related Changes

  Once you’ve split a story and have it at an appropriate size, don’t make things worse by adding work to the story. Often this comes in the form of the temptation of related changes. We tell ourselves, “While I’m in that code, I might as well take care of these other lingering changes...” It can very possibly be appropriate to fix a bug or address an old issue while working on a separate issue in the same part of the code. However, the prioritiy of doing so needs to be considered in the same manner in which priorities were considered for other features. In other words, which is higher priority: spending a half-day fixing a year-old bug or spending the same amount of time on something else? The answer is clearly entirely contextual and becomes this chapter’s final guideline: Avoid making things worse by adding related changes to an appropriately sized feature, unless the related changes are of equivalent priority.

* Combining Stories

  With all of this advice about splitting stories, it may be tempting to think that every user story a team is about to work on should be made as small as possible. Tha’s not the case. For teams working in two-week iterations, splitting features such that each can be done in 2–5 days or so is appropriate. (Stories are still estimated in story points but by the time a team needs to split stories they will know approximately how many story points or ideal days equates to around 2–5 days.) Stories will need to be a little smaller for one-week iterations and can, but don’t need to, be a little larger for longer iterations. Stories of these approximate sizes flow best through the short iterations of an agile project.

  Just as we may need to split large stories, we may need to combine multiple tiny stories. The combined stories are estimated as a whole rather than individually. When possible try to combine related stories as that will make it easier to prioritize them. It is very common to combine multiple bug reports and treat them as one unit.


===================
Part IV. Scheduling
===================


13. Release Planning Essentials
-------------------------------

Release planning is the process of creating a very high-level plan that covers a period longer than an iteration. A typical release will cover perhaps three to six months and maybe three to twelve or more iterations, depending on how long the iterations are. A release plan is important for a number of reasons:

1. It helps the product owner and the whole team decide how much must be developed and how long that will take before they have a releasable product.
2. It conveys expectations about what is likely to be developed and in what timeframe. Many organizations need this information because it feeds into other strategic planning activities.
3. It serves as a guidepost toward which the project team can progress. Without the concept of a release, teams move endlessly from one iteration to the next. A release plan provides context that allows iterations to combine into a satisfying whole. This is a fundamental concern with any iterative process, not just agile ones.


The Release Plan
----------------

Part of planning a release is determining how much can be accomplished by what date. In some cases we start with a date and see how much can be finished by then. In other cases we start with a set of user stories and see how long it will take to develop them. In both cases, once a team has an initial answer, it is assessed against the organization’s goals for the project: Will the product developed make the desired amount of money? Will it save enough money? Will the product capture the target market share? If not, perhaps a longer or shorter project may achieve an acceptable set of goals.

At a cursory level, determining how much work will fit into a release and what user stories that will be is a very straightforward process. Multiplying the planned number of iterations by either the expected or known velocity of the team gives us the total amount of work that can be performed.

During release planning we do not want to create a plan that indicates which developers will work on which user stories or tasks or the sequence in which work will be performed within an iteration. Creating a plan with that level of detail is dangerous and misleading during release planning. Decisions about who works on what and the sequence of activities are best left to the individuals working on those tasks and are best deferred as long as possible. Additionally, remember that items in a release plan are user stories, which are descriptions of the functionality to be delivered, not individual engineering tasks to be performed. During release planning it is too early and some user stories may be insufficiently understood to be disaggregated into engineering tasks. The team will eventually disaggregate the user stories of the release plan into their constituent tasks. But, they won’t do this until the beginning of the iteration containing those stories.

Naturally, should your project, organization, and work environment warrant it, you can include additional information in a release plan. For example, you may wish to communicate some key assumptions underlying the plan (who is on the team, how long an iteration will be, etc.).

The general steps to planning a release is:

1 .Determine conditions of satisfaction
2. Estimate user stories
3. Select iteraion length, Estimate Velocity, Prioritize user stories
4. Select stories and a release date
5. goto 1

* Determine the Conditions of Satisfaction

  Before starting to plan a release, it is important to know the criteria by which the project will be evaluated as a success or a failure. For most projects, the ultimate scorecard is the amount of money saved or generated. As leading indicators of whether a project is likely to achieve these financial goals, most projects use the triumvirate of schedule, scope, and resources. For most projects, this means that the product owner’s conditions of satisfaction are defined by a combination of schedule, scope, and resource goals.

  The product owner will bring desired targets for each of these factors into almost every release planning meeting. A product owner may want four themes (worth 200 story points) developed in three months without adding personnel, for example. While a target for each factor is often identified, one is usually preeminent. Many project ares either date-driven or feature-driven. A date-driven project is one that must be released by a certain date but for which the feature set is negotiable. A feature-driven is one that we would probably like to release as soon as possible but consider the completion of a set of features more important.

* Estimate The User Stories

  Because an estimate represents the cost of developing a user story, it is important that each has been estimated. It is not necessary to estimate everything that a product owner may ever want. It is only necessary to have an estimate for each new feature that has some reasonable possibility of being selected for inclusion in the upcoming release. Often, a product owner will have a wish list that extends two, three, or more releases into the future. It is not necessary to have estimates on the more distant work.

* Select an Iteration Length

  Most agile teams work in iterations of from one to four weeks. It’s possible to go slightly longer and some teams have experimented with even shorter iterations. When planning a release, an appropriate iteration length will need to be chosen.

* Estimate Velocity

  If the team has experience working together, your best bet is often to use the velocity the team exhibited most recently. Naturally, if the technology or business domain changed dramatically, it may not be appropriate to use a team’s past velocity. Still, there are techniques you can apply that enable you to make an informed estimate of velocity based on past results. We'll discuss that later.

* Prioritize User Stories

  Most projects have either too little time or too many features. It is often impossible to do everything that everyone wants in the time allowed. Because of this, the product owner must prioritize the features she wants developed. A good product owner will accept ultimate responsibility for prioritizing, but will listen to advice from the development team, especially about sequencing.

* Select Stories and A Date

  If the project is feature-driven, we can sum the estimates of all needed features and divide by the expected velocity. This will give us the number of iterations necessary to complete the desired functionality.

  If the project is date-driven, we can determine the number of iterations by looking at a calendar. Multiplying the number of iterations by the expected velocity will tell us how many story points or ideal days will fit in the release. We can count off that many points or ideal days into the prioritized list of user stories and see how much functionality can be delivered in the desired time.

  The next question to be addressed regards how detailed the release plan will be. Some teams in some environments prefer to create a release plan that shows what they expect to develop during each iteration. Other teams prefer simply to determine what they think will be developed during the overall release, leaving the specifics of each iteration for later. This is something to be discussed and decided during release planning.

  There are advantages and disadvantages to each approach. Obviously, assigning specific features to specific iterations takes more time. However, the additional detail this provides can be useful when coordinating work among multiple teams. On the other hand, not allocating work to specific iterations provides less detail, but it takes much less time. Further, even if we do preliminarily assign work to specific iterations, we do so with less knowledge than we’ll have at the start of each iteration. Undoubtedly, the plan will change as we learn more throughout the project. So, the investment of time and effort to assign work to specific iterations should be weighed against this. Still, on some projects it may be worth doing. What I find to be a good compromise is to place specific work into the first one to three iterations, treating the rest of the release plan as one large bucket. It’s almost always worth allocating specific work to the first iteration, especially if it is starting immediately.


Updating The Release Plan
-------------------------

At this point, the release plan is done. However, it’s important that the release plan isn’t filed away somewhere or put up on a shelf never to be touched again. The release plan should be revisited and updated with some regular frequency. If the development team’s velocity has remained fairly constant and iteration planning hasn’t introduced any big surprises, you may want to go as long as four to six weeks without formally updating the release plan. On the other hand, many projects benefit from establishing a rule that the release plan will be revisited after each iteration.

A release plan is a high-level plan that covers a period longer than an iteration. For most teams a release occurs every three to six months, but it is not unusual to have releases more or less frequently depending on the type of software.


14. Iteration Planning
======================

An iteration plan is created in an iteration planning meeting. This meeting should be attended by the product owner, analysts, programmers, testers, database engineers, user interaction designers, and so on. Anyone involved in taking a raw idea and turning it into a functioning product should be present.

An iteration plan can be as simple as a spreadsheet or a set of note cards with one task handwritten on each card. In either case, tasks and stories should be organized so that it’s possible to tell which tasks go with which stories. 

One of the most significant advantages to using note cards during iteration planning is that it allows everyone to participate in the process. If tasks are being typed into a system during the iteration planning meeting, someone has his or her fingers on a keyboard. There is tremendous power to having control over the keyboard. All conversations had better involve the typist or nothing will get entered into the release plan. Worse, whoever has the keyboard can change what gets entered into the release plan.


Tasks Are Not Allocated During Iteration Meeting
------------------------------------------------

Individuals do not sign up for tasks until the iteration begins and generally only sign up for one or two related tasks at a time. New tasks are not begun until previously selected ones are completed. There’s nothing to gain and quite a bit to lose by assigning individuals to specific tasks during iteration planning. Projects do best when they foster a "we’re all in this together" attitude; when team members pick up slack for each other knowing that the favor will be returned. When individuals sign up for specific tasks at the beginning of the iteration it works against fostering a unified commitment to achieving the goals of the iteration.


How Iteration Planning Differs From Release Planning
----------------------------------------------------

While the release plan looks forward through the release of the product, usually three to six months out at the start of a new project, the iteration plan looks ahead only the length of one iteration, usually one to four weeks. The user stories of the release plan are decomposed into tasks on the iteration plan. Where the user stories of a release plan are estimated in story points or ideal days, the tasks on the iteration plan are estimated in ideal hours.

The primary purpose of iteration planning is to refine suppositions made in the more coarse-grained release plan. The release plan is usually intentionally vague about the specific order in which user stories will be worked on. Additionally, at the time of iteration planning the team knows more than when the release plan was last updated. Planning the iteration as it begins allows the team to make use of their recently acquired knowledge. In this way, agile planning becomes a two-stage process. The first stage is the release plan, with its rough edges and general uncertainties. The second stage is the iteration plan. An iteration plan still has some rough edges and continues to be uncertain. However, because it is created concurrent with the start of a new iteration, an iteration plan is more detailed than a release plan.

Creating the iteration plan leads a team into discussions about both product design as well as software design. Product design discussions, for example, may be around topics such as the best combination of stories for optimizing value, interpretation of feedback from showing working software to customers, or the extent to which a desired feature should be implmented (that is, will 20% of the feature and effort deliver 80% of the value). Software design discussions may, for example, involve the appropriate architectural tier in which to implement a new feature, which technologies should be used, whether existing code can be reused, and so on. As a result of these discussions the team comes to a better understanding of what should and will be built and they also create a list of the tasks needed to achieve their goal for the iteration.

Iteration planning is not necessary on Monday. (Jan: I think start on Friday and end on Thursday is a good idea.)


At a broad level, there are two ways of planning an iteration, which I refer to velocity-driven and commitment-driven. Different teams use different approaches and each can be successful. Additionally, the two general approaches can be combined to varying degrees.


Velocity-Driven Iteration Planning
----------------------------------

First, the team collaboratively adjusts priorities. They may have learned something in the prior iteration that alters their priorities. Next, they identify the target velocity for the coming iteration. The team then selects an iteration goal, which is a general description of what they wish to accomplish during the coming iteration. After selecting an iteration goal, the team selects the top priority user stories that support that goal. As many stories are selected as necessary for the sum of their ideal day or story point estimates to equal the target velocity. Finally, each selected story is split into tasks and each task is estimated.

1. Adjust priorities. Determine target velocity.

   Ideally, a team should wait until after the iteration review meeting before discussing priorities for the coming iteration. You may need a prioritization meeting for two days before the end of the iteration.

   The default assumption by most teams is that their velocity in the next iteration will equal the velocity of the most recent iteration. Beck and Fowler (2000) call this yesterday's weather since our best guess of today's weather is that it will be like yesterday's weather. Other teams prefer to use a moving average over perhaps the last three iterations.

2. Identify an iteration goal.

   With their priorities and target velocity in mind, the team identifies a goal they would like to achieve during the iteration. The goal succinctly describes what they would like to accomplish during the iteration. The iteration goal is a unifying statement about what will be accomplished during the iteration. It does not have to be very specific.

3. Select user stories.

   In selecting the stories to work on, the product owner and team consider the priority of each story. If a story is too low priority but match the goal, it may not be selected.

4. Split user stories into tasks.

   All tasks necessary to go from a user story to a functioning, finished product should be identified. If there are analysis, design, user interaction design, or other tasks necessary, they need to be identified and estimated. Since the goal of each iteration is to produce a potentially shippable product, take care to include tasks for testing and documenting the product. Including test tasks is important because the team needs to think right at the start of the iteration about how a user story will be tested. This helps engage testers right at the start of the iteration, which improves the cross-functional behavior of the team.

   The iteration plan should only identify those tasks that add immediate value to the current project. Obviously that includes tasks that may be considered analysis, design, coding, testing, user interface design, and so on. Don’t include the hour in the morning when you answer email.

   New agile teams are often not familiar with or skilled at writing automated unit tests. However, this is a skill they work to cultivate during the first few iterations. During that period, I encourage programmers to explicitly identify and estimate unit testing tasks. A programmer may, for example, identify that coding a new feature will take eight hours and then writing its unit tests will take five hours. Later, once unit testing has become a habit for the programmers, the programmer would only write one card saying to code the new feature and would give it an estimate that included time to automate the unit tests. Once something like unit testing becomes a habit, it can be included within another task. Until then, however, making it explicit helps keep awareness of the task high.

   You should identify, estimate, and include tasks for meetings related to the project. When estimating the meeting, be sure to include the time for all participants as well as any time spent preparing for the meeting. For example, suppose the team schedules a meeting to discuss feedback from users. All seven team members plan to attend the one-hour meeting and the analyst plans to spend two hours preparing for the meeting. The estimate for this task is nine hours. I usually enter this into the iteration plan as a single nine-hour task, rather than as a separate task for each team member.

   An agile team has the goal of fixing all bugs in the iteration they are discovered. They become able to achieve this as they become more proficient in working in short iterations, especially through relying on automated testing. When a programmer gives an estimate for coding something that estimate either includes time for fixing any bugs found in the implementation or a separate task ("correct bugs") is identified and estimated. My preference is for identifying a single task but not considering it complete until all of its tests pass.

   A defect found later (or not fixed during the iteration it was discovered) is treated the same as a user story. Fixing the defect will need to be prioritized into a subsequent iteration in the same way any other user story would be. Outside of an iteration, the whole idea of a defect starts to go away. Fixing a bug or adding a feature become two ways of describing the same thing.

   When tasks have dependencies between them, we may need to shift tasks between stories.

   A spike is a task included in an iteration plan that is being undertaken specifically to gain knowledge or answer a question. In this case the team did not have a good guess at something so they created two tasks - one a spike and one a placeholder with a guess at the duration. The spike would help the team learn how they’d approach the other task, which would allow them to estimate it.

5. Estimate tasks.

   Some teams prefer to estimate tasks after all have been identified, other teams prefer to estimate tasks as each is identified. Task estimates are expressed in ideal time. So, if I think that a task will take me six hours of working time I give it an estimate of six hours. I do this even if six hours of time on the task will take me an entire day. Task estimating on an agile project should be a group endeavor, because:

     1. Tasks are not allocated to specific individuals during iteration planning it is impossible to ask the specific person who will do the work.
     2. Even though we expect a specific individual will be the one to do a task and even though he may know the most about that task, it does not mean that others have nothing to contribute. 
     3. Hearing how long something is expected to take often helps teams identify misunderstandings about a user story or task. 
     4. When the person who will do the work provides the estimate, the person’s pride and ego may make him reluctant to later admit that an estimate was incorrect. When an estimate is made collaboratively, this reluctance to admit an estimate is wrong goes away.

   Some design discussion is ok, but talking about models or class diagram is not a good sign. It’s not necessary to go so far as drawing a design because all that’s necessary at this point are guesses about the work that will be needed to complete the features. If you get into the iteration and discover the tasks are wrong, get rid of the initial tasks and create new ones. If an estimate is wrong, cross it out and write a new value. Writing tasks and estimates on note cards is a great approach because each card carries with it a subtle reminder of impermanence.

   The tasks you create should be of an approximate size so that each developer is able to finish an average of one per day. This size works well for allowing work to flow smoothly through your agile development process. Larger tasks tend to get bottled up with a developer or two and the rest of the team can be left waiting for them to complete the task. Additionally, if the team is holding short daily meetings (Schwaber and Beedle 2002; Rising 2002), having tasks of this size allows each developer to report the completion of at least one task on most days. Naturally, there will often be tasks that are larger than this. But, larger tasks should be generally understood to be placeholders for one or more additional task that will be added as soon as they are understood. If you need to create a sixteen-hour task during iteration planning, do so. However, once the task is more adequately understood, augment or replace it. This may mean replacing the initial card with more or less than the initially estimated sixteen hours.


Commitment-Driven Iteration Planning
------------------------------------

Rather than creating an iteration plan that calls for completing as many story points or ideal days as were completed in the prior iteration, the team is asked to add stories to the iteration one-by-one until they can commit to completing no more.

1. Adjust priorities. Identify an iteration goal.

2. Select a story to add. Expand the story into tasks. Estimate tasks.

   In commitment-driven iteration planning stories are selected, decomposed into tasks, and the tasks estimated one story at a time. This is different from the velocity-driven approach, in which a set of stories whose estimates equalled the estimated velocity were selected.

3. Ask for team commitment: if can commit and not full, goto 2; if cannot commit, goto 4; if can commit and full, goto 5.

   In their study of what makes teams successful, Larson and LaFasto (1989) determined that a unified commitment made by all team members is one of the key factors contributing to team success. During an iteration planning meeting I ask the team, “Can you commit to delivering the features we’ve discussed.” Notice that the question I ask is not “Can you commit to delivering the tasks we’ve identified?” That is a very different question, and a far weaker commitment since it is a commitment to complete a set of tasks rather than a commitment to deliver new functionality. If new tasks are discovered during the iteration (and they almost certainly will be), a team that is committed to delivering the functionality described by a user story will try to complete the new tasks as well. A team that committed only to an identified list of tasks may not. In either case, it is possible that the newly discovered tasks will take long enough that they cannot be completed during the iteration. In that case, the team will need to discuss the situation with the product owner and see if there is still a way to meet the iteration goal; they may need to reduce the functionality of a story or drop one entirely.

   I ask a team if they can commit after each user story is split into tasks. After discussing the first feature of a new iteration, the question often seems silly. There may be seven people on the team, planning to work a two-week iteration. Perhaps they’ve only identified 34 hours of work so far and I ask if they can commit to it. Their answer (either verbal or through the confused looks on their faces) is “Of course we can commit to this. There are seven of us for two weeks and this is only 34 hours of work.” However, as the meeting progresses and as more user stories are brought into the iteration, the answer to my question of "can you commit?" begins to require some thought. Eventually, we reach a point where the team cannot commit any further. If they cannot, they may choose to drop a story and replace it with a smaller one before finishing.

   The best way I’ve found for a team to determine whether they can commit to a set of user stories is to sum up the estimates given to the tasks and see if the sum represents a reasonable amount of work. Here we need give an estimate on team capacity too, how many man-hours we can put on this iteration, exclude communication, email reading time?

   Before committing to the work of an iteration, the teams needs to look at the tasks and get a feel for whether they represent an appropriate distribution of work based on the various skills within the team.

   In addition to making progress on a project, many teams are also responsible for support and maintenance of another system. It may be a prior version of the product they are working on or it may be an unrelated system. When a team makes a commitment to complete a set of stories during an iteration they need to do so with their maintenance and support load in mind. I am not referring to general bug fixes that can be prioritized in advance. Those should go through the regular itertion planning prioritization process. By maintenance and support acticities I mean those unpredictable but required parts of many team’s lives—supporting a production website or database, taking support calls from key customers or first-tier technical support, and so on. I think of an iteration as an empty glass. The first things poured into the glass are the team’s unchangeable commitments, such as to support and maintenance of other products. Whatever room remains in the glass is available for the team when they commit to the work of an iteration.

   In most situations, the team will not be able to predict their upcoming support load very accurately. They should know a long-term average, but averaging twenty hours of support per week is not the same as having twenty hours every week. If the support and maintenance load exceeds expectations during an iteration, they may not be able to meet their commitment. They need to counter this by trying to exceed their commitment when the support and maintenance load is less than expected in some iterations. This variability is inescapable on teams with significant support and maintenance obligations.

4. Remove a user story.
5. Iteration planning is done.


Mike Cohn's Recommendation
--------------------------

While both velocity-driven and commitment-driven iteration planning are viable approaches, my preference is for the commitment-driven approach. While velocity plays a critical role in release planning, I do not think it should play an equivalent role in iteration planning. There are two reasons for this. First, because velocity is a measure of coarse-grained estimates (story points or ideal days) it is not accurate enough for planning the work of short iterations. We can use these coarse-grained estimates for estimating the overall amount of work a team will complete during an iteratin. We cannot, however, use them in the same way for planning the shorter-term work of a single iteration.

Second, a team would need to complete twenty to thirty user stories per iteration for errors in the story point or ideal day estimates to average out. Very few teams complete this many stories in an iteration. To see the result of these problems, suppose a team has had a velocity of thirty in each of the past five iterations. That’s about as consistent as it gets and it’s likely they’ll complete thirty points again in the coming iteration. However, we know that not all five-point stories are the same. If we were to sort through a large collection of five-point stories we know we could identify six five-point stories that all looked slightly easier than five points. We might be wrong on some but if this was the first time we tried this, we’d probably succeed. We might increase our velocity from thirty to forty. On the other hand, we could instead select only the five-point stories that seem slightly harder. We still think they should be estimated at five points but they are slightly harder than the other five-point stories.

We’re not going to dig through our collection of user stories and try to find the "easy fives" or the "hard fives." However, most teams plan between three and a dozen stories into each iteration. When pulling that few stories into an iteration, a team will certainly get lucky and select all slightly easy ones or unlucky and select all slightly harder ones occasionally. Because too few stories are completed in a single iteration for these to average out, I prefer not to use velocity when planning an iteration. However, since these differences do average out over the course of a release, velocity works extremely well for release planning.

Story points relate to task estimate (hours) on average only. A story point may equal 10 hours on average, but a story with 1 point may take longer time than a story with 2 points. The differences will be averaged out in long term, but it's there in an iteration.


15. Selecting An Iteration Length
=================================

Factors in Selecting an Iteration Length
----------------------------------------

Your selection of iteration length should be guided by the following factors. Note there is no predetermined importance to these factors. The importance of each is entirely dependent upon the context of the project.

* The overall length of the release being worked on

  Short projects benefit from short iterations. The length of a project’s iterations determines:

  - how often the software can be shown (in potentially shippable form) to users and customers.
  - how often progress can be measured.
  - how often the product owner and team can refine their course since priorities and plans are adjusted between iterations.

  My general rule-of-thumb is that any project will benefit from having at least four or five such opportunities. This means that if the overall project duration will be four or more months, it might be worth considering monthly or four-week iterations. If the overall release will, however, be shorter, the project will benefit from proportionally shorter iterations.

* The amount of uncertainty

  The more uncertainty of any type there is, the shorter the iterations should be. When there is a great deal of uncertainty about the work to be done or the product to be built, short iterations allow more frequent opportunites for the team to measure its progress through its velocity and more opportunities to get feedback from stakeholders, customers, and users.

* The ease of getting feedback

  Iteration length should be chosen to maximize the amount, frequency, and timeliness of feedback to the whole team. Depending on the environment, this may mean longer or shorter iterations. In some organizations it is extremely easy to get informal feedback from internal stakeholders or users throughout an iteration, but extemely difficult to get these same individuals to participate in a scheduled end-of-iteration review meeting. Other organizations have the opposite problem—it is difficult to get feedback on a day-to-day basis but stakeholders, users, and others will attend a scheduled, formal review meeting (especially if food is provided).

  Choose your iteration length to maximize the value of the feedback that can be received from those within and outside the organization.

* How long priorities can remain unchanged

  Once a development team commits to completing a specific set of features in an iteration, it is important that they not be redirected from that goal. It is therefore important that the product owner not change priorities during the iteration and that she help protect the team from others who may attempt to change priorities. Because of this, the length of time that priorities can go unchanged is a factor in selecting the iteration length.

  A key consideration is how long it takes a good new idea to be turned into working software. Consider the case of a team using four-week iterations. If we assume that new ideas are equally likely to occur any time during an iteration then, on average, a new idea can be said to occur in the middle of the iteration. That new idea will be prioritized into the next iteration, which starts in two weeks. It will take another four weeks (a full iteration) before the new idea shows up as potentially shippable, working software. The key point to remember from this example is that the time from new idea to working software will be an average of 1.5 times the length of the team’s iterations.

* Willingness to go without feedback

  The less often a team receives outside feedback, the more likely we may go astray and the greater the loss will be when we found what we delivered is useless at the end of an iteration. To get more feedback, we need short iteration. (Duplicate with 3rd?)

* The overhead of iterating

  There are costs associated with each iteration. For example, each iteration must be fully regression tested. If this is costly (usually in terms of time), the team may prefer longer, four-week iterations. Naturally, one of the goals of a successful agile team is to rapidly reduce (or nearly eliminate) the overhead associated with each iteration. But, especially during a team’s early iterations, this cost can be significant and will influence the decision about the best iteration length.

* A feeling of urgency is maintained

  Colleague Niels Malotaux (2004) points out that, "As long as the end date of a project is far in the future, we don’t feel any pressure and work leisurely... When the pressure of the finish date becomes tangible, we start working harder." Even with four-week iterations the end date is never very far in the future. But, it is sufficiently far away that many teams will feel tangibly less stress during their first week than during the fourth and final week of an iteration.

  The solution to this, of course, is to select an iteration length that evens out the pressure the team feels. The point is not to put the team under more pressume ("You will deliver today!"). Rather, it is to take the total amount of stress they’d normally feel and distribute it more evenly across a suitably long iteration.


Making A Decision
-----------------

One of the main goals in selecting an iteration length is finding one that encourages everyone to work at a consistent pace throughout the iteration. If the duration is too long, there is a natural tendency to relax a bit at the start of the iteration, which leads to panic and longer hours at the end of the iteration. Strive to find an interation duration that smooths out these variations.

Having experimented with a variety of iteration lengths, my general preference is two weeks. One-week iterations (or anything shorter) can be very hectic and stressful. The next deadline is never more than four days away. Extremely short iterations leave no time for recovery if a team member is out sick or if anything goes wrong. Unless a project already has fully automated tests for all parts of the system, I do not often recommend starting with one-week iterations.

A four-week iteration, on the other hand, begins to feel like an eternity after having worked in one– and two-week iterations. With four-week iterations I find that the team often has time to investigate and pursue more creative solutions than they may have time for with shorter iterations. An experienced agile team working on a highly exploratory phase of a project may benefit from a four-week iteration. However, four-week iterations have a feeling of very distinct beginnings, middles, and ends. I don’t like how different the relaxed beginning feels
from the more frantic end.

I find two-week iterations to be ideal. The overhead for planning and testing is much more manageable when amortized across two weeks. The first week of a two-week iteration may feel different from the second week but the difference is not as dramatic as on a four week iteration. Additionally, most organizations can (with sufficient training) learn not to adjust priorities for two weeks while doing so for four weeks can be very difficult.


16. Estimating Velocity
=======================

You have the following three options:

* Use historical values
* Run an iteration
* Make a forecast

Regardless of which approach you are using, if you need to estimate velocity you should consider expressing the estimate as a range. 


Use Historical Values
---------------------

The problem with historical values is that they’re of the greatest value when very little has changed between the old project and team and the new project and team. Any personnel or significant technology changes will reduce the usefulness of historical measures of velocity. Before using them, ask yourself questions like these:

* Is the technology the same?
* Is the domain the same?
* Is the team the same?
* Is the product owner the same?
* Are the tools the same?
* Is the working environment the same?
* Were the estimates made by the same people?

The answer to each question is often yes when the team is moving onto a new release of a product they just worked on. In that case, using the team’s historical values is entirely appropriate. Even though velocity in a situation like this is relatively stable, you should still consider expressing it as a range. You could create a range by simply adding and subtracting a few points to the average or by looking at the team’s best and worst iterations over the past two or three months.

However, if the answer to any of the preceding questions is no, you may want to think twice about using historical velocities. Or you may want to use historical velocities but put a larger range around them to reflect the inherent uncertainty in the estimate. To do this, start by calculating the team’s average velocity over the course of the prior release. If they, for example, completed 150 story points of work during ten iterations, their average (mean) velocity was fifteen points.

Before showing how to convert this to a range, take a look at the figure shows the cone of uncertainty. The cone of uncertainty says that the actual duration of a projet will be between 60% and 160% of what we think it is. So, to turn our single-point, average velocity into a range, I multiply it by 60% and 160%.1 So, if our average historical velocity is 15, I would estimate velocity to be in the range of 9–24.

This range may feel large, but given the likely uncertainty at this point it is probably appropriate. Constructing a range in this way helps the project team heed the advice offered in the quote at the start of this chapter that it is better to be roughly right than precisely wrong. A large range around the expected velocity will allow the team to be roughly right about it.


Run An Iteration
----------------

An ideal way to forecast velocity is to run an iteration (or two or three) and then estimate velocity from the observed velocity during the one to three iterations. Because the best way to predict velocity is to actually observe velocity, this should always be your default approach. Many traditional projects get underway with the developers working on the “obvious” requirements or infrastructure, the analysts “finalizing” the requirements, and the project manager putting together a comprehensive list of tasks that becomes the project plan. All of this takes time; often as long as a few iterations on an agile project.

Most project managers can hold off giving an estimate for at least one iteration. If that’s your case, use the time to run an iteration and measure the velocity. Then create a range around that one data point using the cone of uncertainty. So, if you ran one iteration and had a velocity of 15, turn it into a range by multiply by 0.60 and 1.6, giving a range of 9–24.

If a team can run three or more iterations before being giving an estimate of velocity, they have a couple of additional options for determining a range. First and easiest, they can simply use the range of observed values. For example, suppose the team has completed three iterations and had velocities of 12, 15, and 16. They could express velocity as likely to be within the range 12–16.

Alternatively, they could again use the cone of uncertainty. Although there’s no solid mathematical basis for the approach I’m about to describe, it does work and it makes sense. Here’s the approach: Calculate the average velocity for the iterations you’ve run. Then, for each iteration completed, move one step to the right on the cone of uncertainty. So, for a team that has run one iteration, use the range for the "initial product definition" milestone. If the team has run two iterations, use the range for the “approved product definition” milestone (80% to 120%), and so on. For convenience, these numbers are shown in Table below:

Iterations Completed  | Low Multiplier  | High Multiplier
---------------------------------------------------------
1                     | 0.6             | 1.6
---------------------------------------------------------
2                     | 0.8             | 1.25
---------------------------------------------------------
3                     | 0.85            | 1.15
---------------------------------------------------------
4 or more             | 0.90            | 1.10

Range = (average*low, average*high)

I normally don’t extend this analysis past three or four iterations. I don’t use the cone of uncertainty, for example, to pretend that after six iterations the team precisely knows their velocity and it won’t waver through the end of the project.

Some organizations will be resistant to starting a project without having any idea how long it will take. In such cases, it is important to stress that your desire to run a few iterations first stems not from a desire to avoid making an estimate but to avoid making an estimate without adequate foundation. You’ll want to stress that the purpose of these initial iterations is to assess the dark corners of the system, better understand the technologies involved, refine the understanding of the requirements, and measure how quickly the team can make progress on this project.


Make a Forecast
---------------

There are times when we don’t have historicals and it is just not feasible to run a few iterations in order to observe velocity. For example, suppose the estimate is for a project that won’t start for twelve months. Or suppose the project may start soon, but only once a client signs a contract for the work. There are two key differences in cases like this: First, you want to minimize the expenditure on the project so you won’t actually start running iterations on a project that may not happen or that is too far in the future; Second, any estimate of velocity on these projects must reflect a high degree of uncertainty.

In cases like these, we need to forecast velocity. Forecasting velocity is rarely your first option but it’s an important option and one you should have in your bag of tricks. The best way to forecast velocity involves expanding user stories into their constituent tasks, estimating those tasks (like we do when planning an iteration), seeing how much work fits into an iteration, and then calculating the velocity that would be achieved if that work were finished in an iteration. This involves the following steps:

1. Estimate the number of hours that each person will be available to work on the project each day.

   From observation and discussion with colleagues, my opinion is that most individuals who are assigned full-time to a project spend between four and six hours per day on that project. This fits with an empricial measurement that showed individuals average 55% of their time on project activities. At the high end, Kennedy (2003) reports that engineers in Toyota - with its highly efficient, lean process - are able to spend 80% of their time on their designated projects.

   Use these numbers as parameters in estimating the amount of time individuals on your project team will be able to dedicate each day to the project. If you are part of a large bureaucracy, you will most likely be at the low-end of the scale. If you are part of a three-person startup in a garage, you’ll probably be at the high-end. 

2. Determine the total number of hours that will be spent on the project during the iteration.

   This step is simple, multiply the number of hours available each day by the number of people on the team and the number of days in each iteration. When I introduce this approach to some teams, they want to factor in additional adjustments for vacations, sick time, and other such interruptions. Don’t bother; it’s not worth the extra effort and it’s unlikely to be more accurate anyway. These events are part of the reason why we don’t plan on a team being 100% available in the first place.

3. Arbitrarily and somewhat randomly select stories and expand them into their constituent tasks. Repeat until you have identified enough tasks to fill the number of hours in the iteration.

   The next step is to expand stories into tasks, estimate the tasks, and keep going until we’ve filled the estimated number of available hours. It is not necessary that stories be expanded in priority order. What you really want is a fairly random assortment of stories. 

   Continue selecting stories and breaking them into tasks as long as the tasks selected do not exceed the capacity of the individuals on the team. Select stories until one skill set on the team can’t handle any more work. Add up the story points or ideal days for the work selected and that is the team’s possible velocity.

   It's not necessary to fill the capacity full. Maybe the capacity is 240 but your team think 221 hours tasks now is enough, they can't commit more, then stop there.

4. Convert the velocity determined in the prior step into a range.


Which Approach Should I Use
---------------------------

* If you can run one or more iterations before giving an estimate of velocity, always do so. There’s no estimate like an actual and seeing the team’s actual velocity is always your best choice.
* Use the actual velocity from a related project by this team.
* Estimate velocity by seeing what fits.

Regardless of which approach you use, switch to using actual, observed values for velocity as soon as possible. 


17. Buffering Plans for Uncertainty
===================================

In cases there is either greater uncertainty or greater implication to being wrong about a release schedule. Because of this, it is useful to include a buffer in the determination of the schedule. A buffer is a margin for error around an estimate. The buffer helps protect the project against the impact of the uncertainty. 


Feature Buffers
---------------

Creating a feature buffer is simple to do on an agile project. First, the customer selects all of the absolutely mandatory work. The estimates for that work are summed. This represents the minimum that can be released. The customer then selects another 25–40% more work, selecting toward the higher end of the range for projects with more uncertainty or less tolerance for schedule risk. The estimates for this work are added to the original estimate resulting in a total estimate for the project. The project is then planned as normal for delivery of the entire set of functionality; however, some amount of the work is optional and will only be included if time permits. The optional work is developed last, only after the mandatory work is complete.

  This feature buffering process is consistent with that used in the agile process, DSDM (the Dynamic Systems Development Method). On DSDM projects requirements are sorted into four categories: Must Have, Should Have, Could Have, Won’t Have. DSDM refers to this sorting as the MoSCoW rules. No more than 70% of the planned effort for a project can be targeted at Must Have requirements. In this, DSDM projects create a feature buffer equivalent to 30% of the duration of the project.


Schedule Buffers
----------------

For a trip to the airport it is not appropriate to take a guess at my rate of progress (my velocity) and then provide the airline (the customer) with periodic updates about my expected arrival time. My expected arrival time and my rate of progress don’t matter to the airline; the departure time is fixed, just like deadlines are on many software development projects. In this cases, a schedule buffer protects against uncertainty that can affect the on-time competion of the project.

Note that I am not concerned with whether any one activity (driving, parking, checking in, or going through security) takes too long. I am only concerned with whether the overall chain of activities takes too long. In order to successfully make my flight, I add a 30 minute buffer to my overall schedule for getting to the airport. What we’d like to do is add a similar schedule buffer to projects with greater uncertainty or with greater consequences for missing a deadline.

* Reflecting Uncertainty In Estimates

  In order to protect a project schedule against uncertainty we need a way to quantify the uncertainty. There is normally not much that can be done to accelerate the completion of a task but there are an indefinite number of things that can go wrong and delay the completion of a task. 

  Suppose we want to be 90% confident in the schedule we commit to. One initial approach to doing this might be to estimate the 90% likely duration for each user story in the project and then use those estimates. However, if we do this, the project schedule will almost certainly be too long.

  The plan should protect the only deadline that matters - the overall project deadline. Because it isn’t important if any one task on my way to airport finishes late, I do not need to buffer the on-time completion of the tasks. We should remove local safety from the individual tasks and puts a fraction of that time into a buffer that protects the overall schedule. (The additional time between the 50% and the 90% estimate is called local safety.)

  By moving local safety into an overall project buffer, we are able to avoid the impact of Parkinson’s Law and student syndrome. As you’ll recall from Chapter 2, “Why Planning Fails,” Parkinson’s Law says that work expands to fill the time available. Student syndrome (Goldratt 1997) refers to starting something at the last possible moment that doesn’t preclude successful completion; for example, starting a college term paper three days before it’s due. Because it avoids the problems caused by Parkinson’s Law and student syndrome, a shorter schedule that includes a schedule buffer is more likely to be met than is a longer schedule.

  To create a schedule buffer for a software project, the first thing we need to do is revise our estimating process so that it generates two estimates for each user story or feature. Just like with the trip to the airport, we need to know the 50% and the 90% estimate for each. This is easy enough: When the team meets to estimate, start by estimating the 50% case for the first story. Then estimate the 90% case for that story before moving on to the next story or feature.

* Sizing the Project Buffer

  Since our estimates are at the 50% and 90% points for each item, this means that the difference between these two estimates is about two standard deviations. The standard deviation for each item is then (wi – ai)⁄2 , where wi represents the worst case (90% estimate) for story i and ai represents the average case (50% estimate) for the same story. We’d like the project buffer to protect the overall project to the same 90% level that each task was protected by its own 90% estimate. This means our project buffer should be two standard deviations and can be determined from this formula:

    2σ = 2 × sqrt( ((w1 – a1)⁄2)^2 + ((w2 – a2)⁄2)^2 + ... + ((wn – an)⁄2)^2 )

  where σ is the standard deviation. This can be simplifed to the following:

    2σ = sqrt( (w1 – a1)^2 + (w2 – a2)^2 + ... + (wn – an)^2 )

  (This is why this buffer sizing techninque is commonly called the “Square Root of the Sum of the Squares” approach.)

  The spread between the 50% and 90% estimates influences the size of the project buffer. The user story that contributes the most to the size of the schedule buffer (the first story) is the one with the most uncertainty. Adding in a schedule buffer may or may not add one or more iterations to the length of a project. Most often it will.

  The preceding approach to sizing the project buffer is the best way to size the project buffer. But if for some reason you cannot come up with both 50% and 90% estimate there is a simpler way to size the project buffer. Estimate each story at the 50% level and then set the buffer at half the size of the sum of the 50% estimates. The best way to make sure you’re using 50% estimates is to draw something like Figure 17.1 on a white board and explain that everyone should be estimating with the 50% case in mind. Explain that we want estimates that are just as likely to be high as they are to be low. While this calculation is far simpler, it has the serious flaw of not being influenced by the actual uncertainty around the specific user stories in the project.

  Regardless of whether you prefer the take the square root of the sum of the squares approach or the 50% approach, you should consider these additional guidelines based on advice from Leach (2000):

  - The square root of the sum of the squares approach is most reliable if there are at least ten user stories or features being estimated. But, if your project has fewer than ten items you probably shouldn’t be planning with a buffer anyway.
  - The project buffer should represent at least 20% of the total project duration. A smaller buffer may not provide adequate protection for the overall project.


Combining Buffers
-----------------

At first it may seem like overkill to have multiple buffers. However, it is often appropriate to use multiple buffers because we are protecting the project against multiple types of uncertainty. We should always buffer a given type of project uncertainty with the right units, which means we buffer feature uncertainty with features and schedule uncertainty with time. Additionally, when multiple buffers are used, the size of each can be smaller.

Also, keep in mind that a project may use other buffers besides feature and schedule. A project may include a budget buffer where, for example, thirty developers are assigned to the project while the budget allows up to thirty-three. This is a common practice on medium and large projects but is seen less frequently on small projects for two reasons:

  1. The additional person or two who would make up the personnel buffer on a small project would almost certainly be able to make direct contributions to the project. There may be little or no productivity gains in fully staffing from 30 to 33 developers. There will, however, almost certainly be productivity gains from fully staffing from 4 to 5.

  2. It is difficult to buffer anything in small numbers. When a 30-person project has a three-person buffer to a full staff size of 33 it has a 10% personnel buffer. A similarly sized buffer on a four-person project implies a buffer of four-tenths of a developer. Clearly, it’s easier to add whole rather than partial people to a project.


A Schedule Buffer Is Not Padding
--------------------------------

The term padding has the pejorative meaning of excess time arbitrarily added to an estimate. I pad an estimate when I think it will take three days but decide to tell you five, just in case. Individuals add padding to an estimate if they expect to be beaten up if they are wrong. A schedule buffer is different: A schedule buffer is a necessary margin of safety added to the sum of estimates from which local safety has been removed.

When we allow small amounts of flexibility in both delivery date and functionality we can buffer two dimensions of the project. More importantly, we buffer each project constraint with the appropriate resource: We buffer the deadline with time; we buffer functionality with functionality. When we cannot buffer a constraint appropriately, we are forced to increase the size of other buffers. If I am forced to guarantee the functionality then I will support that guarantee with a larger schedule buffer.


Caveats
-------

* When adding a schedule buffer, either use the two-estimate approach described in this chapter or be sure that the single-value estimates represent estimates at the 50% point. Adding a schedule buffer on top of already pessimistic, 90% estimates will result in an overly long schedule.

* On many projects, a precise deadline with a precise set of delivered functionality is not needed. Instead the team simply needs to deliver high-quality software as fast as possible over a sustained period. If you’re in this situation, don’t take on the small extra work of adding buffers to your project.

* Be careful with how you communicate buffers. You should not hide their existence or how they are used. However, a buffer (especially a schedule buffer) can appear to be padding. This means you’ll need to communicate how you derived the estimates and the buffer and how the buffer is intended to provide a schedule everyone can be 90–95% confident in.



18. Planning the Multi-Team Project
===================================

Agile teams are often described as having no more than seven to ten developers. Teams of this size can accomplish quite a bit, especially with an agile process that allows and encourages them to become more productive. However, there are some projects where we’d like to bring a larger team to bear on the project. Rather than establishing a single 100-person team, the agile approach is to create multiple smaller teams. An agile project may have a dozen smaller teams instead of a single 100-person team.


Establishing a Common Basis For Estimates
-----------------------------------------

At the start of a project, the teams should meet and choose between story points and ideal days. They should then establish a common baseline for their estimates so that an estimate by one team will be similar to that of another team if the other team had estimated the work instead. Each user story only needs to be estimated by one team, but the estimates should be equivalent regardless of which team estimated the work.

There are two good ways to establish a common baseline. The first approach about the stories. Once these baseline stories are agreed upon, the teams may separately estimate stories by comparing them to the baseline stories (that is, es- timating them by analogy). The second approach is similar but involves collaboratively estimating an assortment of new user stories. A variety of stories planned for the new release are selected. The stories should span a variety of sizes and should be in areas of the situation that most of the estimators can relate to. Either the entire large team—or representatives of each sub-team if the entire team is too big—meet and agree upon an estimate for these stories. As with the first approach, these estimates are then used as baselines against which future estimates are compared. The only time separate teams should consider estimating in different units without a common baseline is when the products being built are truly separate and there is absolutely no opportunity for developers from one team to move onto another. Even then, my recommendation is to establish a common baseline as it facilitates communicating about the project.


Adding Details To User Stories Sooner
-------------------------------------

Ideally, an agile team begins an iteration with vaguely defined requirements and turns those vague requirements into functioning, tested software by the end of the iteration. Going from vague requirement to working software in one iteration is usually easier on a single team project than it is when there are multiple teams. On a multiple team project it is often appropriate and necessary to put more thought into the user stories prior to the start of the iteration. The additional detail allows multiple teams to coordinate work.

To achieve this, larger teams often include dedicated analysts, usage interaction designers, and others who spend a portion of their time during a given iteration preparing the work of the next iteration. In general, I do not advise having analysts, interaction designers, and others work a full iteration ahead. Rather, their primary responsibility should remain the work of the current iteration, but in planning the current iteration they should include some tasks related to preparing for the next iteration.

What I’ve found to be the most useful outcome of work done in advance of the iteration is the identification of the product owner’s conditions of satisfaction for the user stories that are likely to be developed during the iteration. A product owner’s conditions of satisfaction for a user story are the high-level acceptance tests that she would like to see applied to the story before considering it finished. A user story is finished when it can be demonstrated to meet all of the conditions of satisfaction identified by the product owner.


Lookahead Planning
------------------

Most teams with either moderately complex or frequent interdependencies will benefit from maintaining a rolling lookahead window during release and iteration and planning. You may recall that in Chapter 13, “Release Planning Essentials,” I advised that the release plan show detail only for the next couple of iterations. This is because that is often enough to support the interdependencies encountered by many teams. When multiple teams need to coordinate work, the release plan should be updated to show and coordinate the work of the next two or three iterations. The exact number of iterations will, of course, depend on the frequency and significance of the dependencies between teams. As iterations are completed, details about them are dropped from the plan. The release plan then becomes a rolling lookahead plan that always outlines expectations about the new few iterations. Laufer (1996) refers to this as “peering forward.”


Incorporating Feeding Buffers Into the Plan
-------------------------------------------

There are situations, however, where the interdependencies between teams are so complex or frequent that the simple rolling lookahead planning of the prior section is not adequate. In these cases, your first recourse should be to try to find a way to reduce the number of interdependencies so that a rolling lookahead plan is adequate. If that cannot be done, consider including a feeding buffer in iterations that deliver capabilities needed by other teams. A feeding buffer, like the schedule buffer of the previous chapter, protects the on-time delivery of a set of new capabilities. This is a somewhat complicated way of saying that if your team needs something from my team tomorrow at 8:00 A.M., my team shouldn’t plan on finishing it at 7:59.

To include a feeding buffer in a release plan, all you need to do is plan temporarily for a lower velocity for the team that is delivering a capability to another team. In many cases, adding feeding buffers will extend the expected duration of a project. But, it usually does so in a way that represents a realistic expectation of the likely schedule, not in a "let’s pad the schedule so we don’t have to work hard" way. Because feeding buffers can prolong a schedule, you want to add them only when necessary.

To determine where feeding buffers are necessary, first allocate user stories among teams and iterations. Then look for critical dependencies between iterations and teams. Finally, add a feeding buffer only between these critical dependencies. That is, add a feeding buffer only if a team will be unable to do planned, high-priority work without the deliverables of another team. Even so, if the team can easily swap in other highly valuable work, a feeding buffer is unnecessary. Similarly, do not add a feeding buffer if the second team will be able to start making progress with a partial deliverable from the first team. If your team can start its work even if my team delivers only half of the planned functionality then a feeding buffer is not needed.

Most inter-team dependencies are based on no more than a handful of stories or features at a time. Because of this you usually won’t have enough stories to effectively use the square root of the sum of the squares approach described in that chapter. In these cases, set the size of the feeding buffer as a percentage of the stories creating the inter- dependency. You can use 50% as a default buffer size but this should be adjusted based on team judgment.

It is possible to have a feeding buffer that is longer than a full iteration. However, it is rarely advisable to use a feeding buffer that long. A feeding buffer that is longer than an iteration is usually the result of planning to pass a large chunk of functionality on to another team. There are two reasons why a project probably doesn’t need a large feeding buffer in these cases. First, the hand-off from one team to another should almost certainly be divided so that the functionality is delivered incrementally. This will allow the second team to get started as soon as they receive the initial set of functionality from the first team. Second, rather than consume an extremely large feeding buffer, the teams would probably find ways of splitting the work or of making other adjustments between iterations as soon as they noticed one team slipping behind. Having the receiving team act as a product owner or customer of the delivering team will allow the two teams to usually work out an incremental delivery sequence that works for both teams.

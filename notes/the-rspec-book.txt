Behavior Driven Development

everything started from here: http://techblog.daveastels.com/2005/07/05/a-new-look-at-test-driven-development/

"Also, the idea of “unit” is a major problem. First of all it’s a vague term, and second it implies a structural division of the code (i.e. people think that they have to test methods or classes). We shouldn’t be thinking about units… we should be thinking about facets of behaviour."

"That’s not what we want… we want behavioural divisions.. we want to work at a level of granularity much smaller than that of the typical unit test. As I’ve said before when talking about TDD, we should be working with very small, focused pieces of behaviour… one small aspect of a single method. Things like “after the add() method is called with an object when the list is empty, there should be one thing in the list”. The method is being called in a very specific context, often with very specific argument, and with a very specific outcome."




BDD is in fact the same thing as TDD, but TDD is a misleading word. People usually understand T in TDD as Test/UnitTest, but it isn't. So BDD is TDD with a whole changed vocabulary.

"As the code base gradually increases in size, more and more attention is consumed by the refactoring step. The design is constantly evolving and under constant review, though it is not pre-determined. This process is known as emergent design, and is one of the most significant by-products of Test Driven Development.

This is not a testing practice at all. Instead, the goal of TDD is to deliver high quality code to testers, but it is the testers who are responsible for testing practices (see the Joe Asks. . . on the current page).

And this is where the Test in TDD becomes a problem. Specifically, it is the idea of Unit Testing that often leads new TDD’ers to verifying things like making sure that a register() method stores a Registration in a Registry’s registrations collection, and that collection is specifically an Array.

This sort of detail in a test creates a dependency in the test on the internal structure of the object being tested. This dependency means that if other requirements guide us to changing the Array to a Hash, this test will fail, even though the behaviour of the object hasn’t changed. This brittleness can make test suites much more expensive to maintain, and is the primary reason for test suites to become ignored and, ultimately, discarded."




Rspec is specifications for objects, Cucumber is specifications for the whole application.

Behavior: as(who), want(what), so(why)
Scenario: given(context)/and, when(input), then(output)

Dir Structure
|- bin
|- features
   |- step_definitions
   |- support
      |- env.rb
|- lib
   |- <project_name>.rb    # require files in <project_name> dir
   |- <project_name>
      |- <source files...>
|- spec
   |- spec_helper.rb
   |- <project_name>.rb
   |- <project_name>


ONE EXPECTATION PER EXAMPLE: The rationale here is that if there are two expectations in an example that should both fail given the implementation at that moment, we’ll only see the first failure. No sooner do we meet that expectation than we discover that we haven’t met the second expectation. If they live in separate exam- ples, then they’ll both fail, and that will provide us with more accurate information than if only one of them is failing.

Refactoring is the process of changing a software system in such a way that it does not alter the external behaviour of the code yet improves its internal structure. - Martin Fowler


Cucumber scenario outlines is inspired by FIT. It's kinda like fixtures for features.

BDD is a design practice, not a testing practice. We need exploratory testing because just as Big Design Up Front fails to allow for discovery of features and designs that naturally emerge through iterative development, so does driving out behaviour with examples fail to unearth all of the corner cases that we’ll naturally discover by simply using the software.

Refactoring step definitions and code examples, keeping in mind that expressiveness and localization are key factors in keeping them maintainable.

Refactoring in the Green: only refactor when all of your examples are passing.

*Enough up-front thinking* is BDD’s response to this. It says you should do enough up-front planning, analysis, and design but no more. So then on a software project how much is enough? The word is intentionally subjective: it will vary from team to team and project to project. One way to think about enoughis to ask whether the team feels safe to continue.

We have two complementary strategies here: we can try to reduce the likelihood of something going wrong, or mitigate its impact. Most tradi- tional project management focuses on the former, which is why there is so much emphasis on the up-front planning and analysis. We want to identify every possible risk so we are more likely to spot the dangerous ones.

Our approach is to place more emphasis on the latter aspect and become good at minimizing the impact of something going wrong. This tech- nique, that The Pragmatic Programmer [HT00] calls failing fast, allows us to experiment with lots of different ideas because we know that if it goes wrong it won’t be that big of a deal. This approach speaks to the Extreme Programming values of courage and feedback: you can be more courageous when you know the stakes aren’t as high, and you can find out quickly whether or not something is a good idea.

In BDD terms a stakeholder is anyone who cares about the work we are undertaking, whether they are the people whose problem we are trying to solve — the core stakeholders — or the people who are going to help solve it — the incidental stakeholders.

vision/purpose of project -> outcomes/goals -> feature-sets/themes -> features/stories

You don’t have to work in iterations, and if you do they don’t have to be one week long. We have seen teams using iterations lasting from half a day (no, really!) to four weeks. Some teams don’t use iterations at all, but have a constant flow of stories that they track using techniques borrowed from Lean manufacturing, such as kanban flow control and finger charts. The important thing is to ensure you have regular feedback from your stakeholders and a way of measuring throughput.


A story is made up of a number of components:

  * A title so we know which story we are talking about

  * A narrative which tells us what this story is about. There are a couple of common formats for this, but you can use anything that captures the essentials. At the very least it should identify the stakeholder for this story, a description of the feature they want, and the reason they want it—the benefit they expect to gain by us delivering this behaviour.  The most common format for this is known as the Connextra for- mat, after the company where it was first used: As a [stakeholder], I want [feature]so that [benefit] A recent variant that is becoming popular looks like this: In order to [benefit], a [stakeholder] wants to [feature]. The content is exactly the same but there is a subtle shift in emphasis by putting the benefit first. It helps keep the focus on the outcome rather than the detail of the feature.

  * Acceptance criteria so we know when we are done. In BDD, the accep- tance criteria take the form of a number of scenarios made up of individual steps.

Although the whole team should be involved in all aspects of fleshing out the story, it is the business analyst3 who “owns” the story title and narrative, and the acceptance criteria is “owned” by the tester, or rather by someone in the tester role.

Jan: Given/When/Then = Context/Input/Output


The Three Principles of BDD:

* It’s all behaviour We want Business and Technology people using the same words to refer to the same ideas. You shouldn’t need a trans- lator between the stakeholders and the development team.

* Deliver stakeholder value If you are doing something that isn’t either delivering value or increasing your ability to deliver value, stop doing it.

* Enough is enough Up-front planning, analysis, and design all have a diminishing return. We shouldn’t do less than we need to get started, but any more than that is wasted effort. This also applies to process automation. Have an automated build and deployment, but don’t get sucked into trying to automate everything.

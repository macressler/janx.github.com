Composing Methods
-----------------

A large part of my refactoring is composing methods to package code properly. Almost all the time the problems come from methods that are too long. Long methods are troublesome because they often contain a lot of information, which gets buried by the complex logic that usually gets dragged in. 

* Extract Method: Turn the fragment into a method whose name explains the purpose of the method. 

    I prefer short, well-named methods for several reasons. First, it increases the chances that other methods can use a method when the method is finely grained. Second, it allows the higher-level methods to read more like a series of comments. Overriding also is easier when the methods are finely grained. It does take a little getting used to if you are used to seeing larger methods. And small methods really work only when you have good names, so you need to pay attention to naming. People sometimes ask me what length I look for in a method. To me length is not the issue. The key is the semantic distance between the method name and the method body. If extracting improves clarity, do it, even if the name is longer than the code you have extracted.

    Name it by what it does, not by how it does it. If the code you want to extract is very simple, such as a single message or function call, you should extract it if the name of the new method reveals the intention of the code in a better way. If you can’t come up with a more meaningful name, don’t extract the code.

* Inline Method: A method’s body is just as clear as its name. Put the method’s body into the body of its callers and remove the method. Another time to use Inline Method is when you have a group of methods that seem badly factored. You can inline them all into one big method and then re-extract the methods.

* Inline Temp: You have a temp that is assigned to once with a simple expression, and the temp is getting in the way of other refactorings. Replace all references to that temp with the expression.

* Replace Temp with Query: You are using a temporary variable to hold the result of an expression. Extract the expression into a method. Replace all references to the temp with the expression. The new method can then be used in other methods.

    The problem with temps is that they are temporary and local. Because they can be seen only in the context of the method in which they are used, temps tend to encourage longer methods, because that’s the only way you can reach the temp. By replacing the temp with a query method, any method in the class can get at the information. That helps a lot in coming up with cleaner code for the class. Replace Temp with Query often is a vital step before Extract Method. Local variables make it difficult to extract, so replace as many variables as you can with queries. The straightforward cases of this refactoring are those in which temps are assigned only to once and those in which the expression that generates the assignment is free of side effects. Other cases are trickier but possible.

    Temps often are used to store summary information in loops. The entire loop can be extracted into a method; this removes several lines of noisy code. Sometimes a loop may be used to sum up multiple values. When this is the case, duplicate the loop for each temp so that you can replace each temp with a query. The loop should be simple, so there is little danger in duplicating the code. You may be concerned about performance in this case. As with other performance issues, let it slide for the moment. Nine times out of ten, it won’t matter. When it does matter, you will fix the problem during optimization. With your code better factored, you often find more powerful optimizations that you would have missed without refactoring. If worse comes to worst, it’s easy to put the temp back.

(J: temp vars will confuse your brain)

* Replace Temp with Chain: You are using a temporary variable to hold the result of an expression. Change the methods to support chaining, thus removing the need for a temp. (R)

    At first glance, Replace Temp With Chain might seem to be in direct contrast to Hide Delegate. The important difference is that Hide Delegate should be used to hide the fact that an object of one type needs to delegate to an object of another type. It is about encapsulation—the calling object should not reach down through a series of subordinate objects to request information—it should tell the nearest object to do a job for it. Replace Temp With Chain, on the other hand, involves only one object. It’s about improving the fluency of one object by allowing chaining of its method calls.

* Introduce Explainning Variable: You have a complicated expression. Put the result of the expression, or parts of the expression, in a temporary variable with a name that explains the purpose.

    In this, and the two refactorings that follow, we introduce temporary variables. It should be stated that temps should not be introduced lightly. Extraneous temporary variables are not a good thing: They can clutter method bodies and distract the reader, hindering their understanding of the code. So why do we introduce them? It turns out that in some circumstances, temporary variables can make code a little less ugly. But whenever I’m tempted to introduce a temporary variable, I ask myself if there’s another option. In the case of Introduce Explaining Variable, I almost always prefer to use Extract Method if I can. A temp can only be used within the context of one method. A method is useful throughout the object and to other objects. There are times, however, when other local variables make it difficult to use Extract Method. That’s when I bite the bullet and use a temp.

(J: extract method is better, but when you can't extract method, introduce explainning var)

* Split Temporary Variable: You have a temporary variable assigned to more than once, but it is not a loop variable nor a collecting temporary variable. Make a separate temporary variable for each assignment.

    Temporary variables are made for various uses. Some of these uses naturally lead to the temps being assigned to several times. Loop variables change for each run around a loop. Collecting temporary variables [Beck] collect together some value that is built up during the method. Many other temporaries are used to hold the result of a long-winded bit of code for easy reference later. These kinds of variables should be set only once. That they are set more than once is a sign that they have more than one responsibility within the method. Any variable with more than one responsibility should be replaced with a temp for each responsibility. Using a temp for two different things is confusing for the reader.

* Remove Assignments to Parameters: The code assigns to a parameter. Use a temporary variable instead.

* Replace Method with Method Object: You have a long method that uses local variables in such a way that you cannot apply Extract Method. Turn the method into its own object so that all the local variables become instance variables on that object. You can then decompose the method into other methods on the same object.

* Substitute Algorithm: You want to replace an algorithm with one that is clearer. Replace the body of the method with the new algorithm.

* Replace Loop with Collection Closure Method: You are processing the elements of a collection in a loop. Replace the loop with a collection closure method. (J: use Enumerable module more). If you finish a line with a period, Ruby knows not to treat the end of line as a statement terminator. When the series of pipes and filters becomes so complex that it’s no longer easy to understand, you might want to consider writing a custom traversal method whose name explains the purpose of the traversal. (R)

* Extract Surrounding Method: You have two methods that contain nearly identical code. The variance is in the middle of the method. Extract the duplication into a method that accepts a block and yields back to the caller to execute the unique code. (R)

* Introduce Class Annotation: You have a method whose implementation steps are so common that they can safely be hidden away. Declare the behavior by calling a class method from the class definition. (R)

* Introduce Named Parameter: The parameters in a method call cannot easily be deduced from the name of the method you are calling. Convert the parameter list into a Hash, and use the keys of the Hash as names for the parameters. (R)

    So much of object-oriented design depends on the effectiveness of the abstractions that you create. Let’s say you have object A that delegates to object B, which in turn delegates to object C. It is much easier to understand the algorithm if each object can be synthesized in isolation by the reader. To provide for this, the clarity of the public interface of the object being delegated to is important. If object B’s public interface represents a cohesive piece of behavior with a well-named class, well-named methods, and parameter lists that make sense given the name of the method, a reader is less likely to have to delve into the details of object B to understand object A. Without this clear abstraction around the behavior of object B, the reader will have to move back and forth between object A and object B (and perhaps object C as well), and understanding of the algorithm will be much more difficult.

* Remove Named Parameter: The fluency that the named parameter brings is no longer worth the complexity on the receiver. Convert the named parameter Hash to a standard parameter list. (R)

    Introduce Named Parameter brings a fluency to the calling code that can be beneficial. But named parameters do come at a price—they add complexity to the receiving method. The parameters are clumped together into one Hash, which can rarely have a better name than “params” or “options”, because the parameters contained within the Hash are not cohesive enough to have a domain-related name. Even if they are named well, it is impossible to tell exactly the contents of the Hash, without examining the method body or the calling code. Most of the time, this added complexity is worth the increased readability on the calling side, but sometimes the receiver changes in such a way that the added complexity is no longer justified. Perhaps the number of parameters has reduced, or one of the optional parameters becomes required, so we remove the required parameter from the named parameter Hash. Or perhaps we perform Extract Method or Extract Class and take only one of the parameters with us. The newly created method or class might now be able to be named in such a way that the parameter is obvious. In these cases, you want to remove the named parameter.

* Remove Unused Default Parameter: A parameter has a default value, but the method is never called without the parameter. Remove the default value. Unused flexibility in software is a bad thing. Maintenance of this flexibility takes time, allows opportunities for bugs, and makes refactoring more difficult. (R)

* Dynamic Method Definition: You have methods that can be defined more concisely if defined dynamically. Define the methods dynamically. (R)
  - Using def_each to Define Similar Methods
  - Defining Instance Methods with a Class Annotation
  - Defining Methods By Extending a Dynamically Defined Module

* Replace Dynamic Receptor: with Dynamic Method Definition: You have methods you want to handle dynamically without the pain of debugging method_missing. Use dynamic method definition to define the necessary methods. (R)

    Debugging classes that use method_missing can often be painful. At best you often get a NoMethodError on an object that you didn’t expect, and at worst you get stack level too deep (SystemStackError). There are times that method_missing is required. If the object must support unexpected method calls you may not be able to avoid the use of method_missing. However, often you know how an object will be used and using Dynamic Method Definition you can achieve the same behavior without relying on method_missing.

* Isolate Dynamic Receptor: A class utilizing method_missing has become painful to alter. Introduce a new class and move the method_missing logic to that class. (R)

    Despite the added complexity, method_missing is a powerful tool that needs to be used when the interface of a class cannot be predetermined. On those occasions I like to use Isolate Dynamic Receptor to move the method_missing behavior to a new class: a class whose sole responsibility is to handle the method_missing cases. By design the functionality of method_missing should handle any unknown message, but how do you know if you’ve broken something by adding an explicitly defined method? The solution to this problem is to introduce an additional class that has the single responsibility of handling the dynamic method calls. 

    Very often it’s possible to know all valid method calls ahead of time, in which case I prefer Replace Dynamic Receptor with Dynamic Method Definition.

(J: method_missing is evil)

* Move Eval from Runtime to Parse Time: You need to use eval but want to limit the number of times eval is necessary. Move the use of eval from within the method definition to defining the method itself. (R)

    As Donald Knuth once said, “Premature optimization is the root of all evil”. I’ll never advocate for premature optimization, but this refactoring can be helpful when you determine that eval is a source of performance pain. The Kernel#eval method can be the right solution in some cases, but it is almost always more expensive (in terms of performance) than its alternatives. In the cases where eval is necessary, it’s often better to move an eval call from runtime to parse time.

    The only step to do this refactoring is Expand the scope of the string being eval’d. It’s also worth noting that evaluating the entire method definition allows you to change the define_method to def in this example. All current versions of Ruby execute methods defined with def significantly faster than methods defined using define_method; therefore, this refactoring could yield benefits for multiple reasons. Of course, you should always measure to ensure that you’ve actually refactored in the right direction.

(J: this is tricky)


Moving Features Between Objects
-------------------------------

One of the most fundamental, if not the fundamental, decision in object design is deciding where to put responsibilities.

* Move Method: A method is, or will be, using or used by more features of another class than the class on which it is defined. Create a new method with a similar body in the class it uses most. Either turn the old method into a simple delegation, or remove it altogether.

    Moving methods is the bread and butter of refactoring. I move methods when classes have too much behavior or when classes are collaborating too much and are too highly coupled. By moving methods around, I can make the classes simpler, and they end up being a more crisp implementation of a set of responsibilities.

* Move Field: A field is, or will be, used by another class more than the class on which it is defined. Create a new attribute reader (and if necessary, a writer) in the target class, and change all its users.

    Moving state and behavior between classes is the essence of refactoring. As the system develops, you find the need for new classes and the need to shuffle responsibilities around. A design decision that is reasonable and correct one week can become incorrect in another. That is not a problem; the only problem is not to do something about it.

    I consider moving a field if I see more methods on another class using the information in the field than the class itself. I may choose to move the methods; this decision is based on interface. But if the methods seem sensible where they are, I move the field. Another reason for field moving is when doing Extract Class. In that case the fields go first and then the methods.

* Extract Class: You have one class doing work that should be done by two. Create a new class and move the relevant fields and methods from the old class into the new class.

    If I choose to expose the class, I need to consider the dangers of aliasing. If I expose the telephone number and a client changes the area code in that object, how do I feel about it? It may not be a direct client that makes this change. It might be the client of a client of a client.  I have the following options:

      • I accept that any object may change any part of the telephone number. This makes the telephone number a reference object, and I should consider Change Value to Reference. In this case the person would be the access point for the telephone number.

      • I don’t want anybody to change the value of the telephone number without going through the person. I should make the telephone number immutable.

      • A third option that reduces that confusion is to clone and then freeze the telephone number before passing it out.

    Extract Class is a common technique for improving the liveness of a concurrent program because it allows you to have separate locks on the two resulting classes. If you don’t need to lock both objects you don’t have to. For more on this see Brian Goetz’s book Java Concurrency in Practice [Goetz]. However, there is a danger there. If you need to ensure that both objects are locked together, you get into the area of transactions and other kinds of shared locks. This is complex territory and requires heavier machinery than it is typically worth. Transactions are useful when you use them, but writing transaction managers is more than most programmers should attempt.

* Inline Class: A class isn’t doing very much. Move all its features into another class and delete it.

* Hide Delegate: A client is calling a delegate class of an object. Create methods on the server to hide the delegate.

    One of the keys, if not the key, to objects is encapsulation. Encapsulation means that objects need to know less about other parts of the system. Then when things change, fewer objects need to be told about the change - which makes the change easier to make.

* Remove Middle Man: A class is doing too much simple delegation. Get the client to call the delegate directly. (J: reversion of Hide Delegate)

    In the motivation for Hide Delegate, I talked about the advantages of encapsulating the use of a delegated object. There is a price for this. The price is that every time the client wants to use a new feature of the delegate, you have to add a simple delegating method to the server. After adding features for a while, it becomes painful. The server class is just a middle man, and perhaps it’s time for
the client to call the delegate directly.

    It’s hard to figure out what the right amount of hiding is. Fortunately, with Hide Delegate and Remove Middle Man it does not matter so much. You can adjust your system as time goes on. As the system changes, the basis for how much you hide also changes. A good encapsulation six months ago may be awkward now. Refactoring means you never have to say you’re sorry: You just fix it.

(J: I'm not convinced. I think most time you don't need these two refactoring.)

* Introducing Foreign Method: A server class you are using needs an additional method, but you can't modify the class. Create a method in the client class with an instance of the server class as its first argument. (O)

* Introduce Local Extension: A server class you are using needs several additional methods, but you can't modify the class. Create a new class that contains these extra methods. Make this extension class a subclass or a wrapper of the original. (O)


Organizing Data
---------------

* Self Encapsulate Field: You are accessing a field directly, but the coupling to the field is becoming awkward. Create getting and setting methods for the field and use only those to access the field.

    When it comes to accessing fields, there are two schools of thought. One is that within the class where the variable is defined, you should access the variable freely (direct variable access). The other school is that even within the class, you should always use accessors (indirect variable access). Debates between the two can be heated. (See also the discussion in Smalltalk Best Practices [Beck].)
    
    Essentially the advantages of indirect variable access are that it allows a subclass to override how to get that information with a method and that it supports more flexibility in managing the data, such as lazy initialization, which initializes the value only when you need to use it. The advantage of direct variable access is that the code is easier to read. You don’t need to stop and say, “This is just a getting method.” I’m always of two minds with this choice. I’m usually happy to do what the rest of the team wants to do. Left to myself, though, I like to use direct variable access as a first resort, until it gets in the way. Once things start becoming awkward, I switch to indirect variable access. Refactoring gives you the freedom to change your mind.
    
    The most important time to use Self Encapsulate Field is when you are accessing a field in a superclass but you want to override this variable access with a computed value in the subclass. Self-encapsulating the field is the first step. After that you can override the getting and setting methods as you need to.

    When you are using self-encapsulation you have to be careful about using the setting method in the constructor. Often it is assumed that you use the setting method for changes after the object is created, so you may have different behavior in the setter than you have when initializing. In cases like this I prefer using either direct access from the constructor or a separate initialization method.

* Replace Data Value with Object: You have a data item that needs additional data or behavior. Turn the data item into an object. (J: the object here is merely a value object, we can add things to it later, but not now. Value object means immutable, whenever you do assignment you're creating a new object, not modify old object. This step can be followed by next refactoring.)

* Change Value to Reference: You have a class with many equal instances that you want to replace with a single object. Turn the object into a reference object.

    You can make a useful classification of objects in many systems: reference objects and value objects. Reference objects are things like customer or account. Each object stands for one object in the real world, and you use the object identity to test whether they are equal. Value objects are things like date or money. They are defined entirely through their data values. You don’t mind that copies exist; you may have hundreds of “1/1/2010” objects around your system. You do need to tell whether two of the objects are equal, so you need to override the eql? method (and the hash method too).

    The decision between reference and value is not always clear. Sometimes you start with a simple value with a small amount of immutable data. Then you want to give it some changeable data and ensure that the changes ripple to everyone referring to the object. At this point you need to turn it into a reference object.

(J: this is a tricky refactoring, involved Factory pattern to gurantee same object have same identity. read book!)

* Change Reference to Value: You have a reference object that is small, immutable, and awkward to manage. Turn it into a value object.

    As with Change Value to Reference, the decision between a reference and a value object is not always clear. It is a decision that often needs reversing. The trigger for going from a reference to a value is that working with the reference object becomes awkward. Reference objects have to be controlled in some way. You always need to ask the controller for the appropriate object. The nks also can be awkward. Value objects are particularly useful for distributed and concurrent systems.

    An important property of value objects is that they should be immutable. Any time you invoke a query on one, you should get the same result. If this is true, there is no problem having many objects represent the same thing. If the value is mutable, you have to ensure that changing any object also updates all the other objects that represent the same thing. That’s so much of a pain that the easiest thing to do is to make it a reference object. It’s important to be clear on what immutable means. If you have a money class with a currency and a value, that’s usually an immutable value object. That does not mean your salary cannot change. It means that to change your salary, you need to replace the existing money object with a new money object rather than changing the amount on an existing money object. Your relationship can change, but the money object itself does not.

* Replace Array with Object: You have an Array in which certain elements mean different things. Replace the Array with an object that has a field for each element.

  Trick: Refactor with Deprecation

    class Module
      def deprecate(methodName, &block)
        module_eval <<-END
          alias_method :deprecated_#{methodName}, :#{methodName}
          def #{methodName}(*args, &block)
            $stderr.puts "Warning: calling deprecated method #{self}.#{methodName}. This method will be removed in a future release."
            deprecated_#{methodName}(*args, &block)
          end
        END
      end
    end

* Duplicate Observed Data: You have domain data available only in a GUI control, and domain methods need access. Copy the data to a domain object. Set up an observer to synchronize the two pieces of data. (O)

* Replace Hash with Object: You have a Hash that stores several different types of objects, and is passed around and used for more than one purpose. Replace the Hash with an object that has a field for each key. (R)

* Change Unidirectional Association to Bidirectional: You have two classes that need to use each other’s features, but there is only a one-way link. Add back pointers, and change modifiers to update both sets.

    The idiom is awkward enough that you should have tests, at least until you are comfortable with the idiom. Because I usually don’t bother testing accessors (the risk is not high enough), this is the rare case of a refactoring that adds a test.

    Who should take the responsibility?

    • If both objects are reference objects and the association is one to many, then the object that has the one reference is the controller. (That is, if one customer has many orders, the order controls the association.)
    • If one object is a component of the other, the composite should control the association.
    • If both objects are reference objects and the association is many to many, it doesn’t matter whether the order or the customer controls the association.

* Change Bidirectional Association to Unidirectional: You have a two-way association but one class no longer needs features from the other. Drop the unneeded end of the association.

* Replace Magic Number with Symbolic Constant: You have a literal number with a particular meaning. Create a constant, name it after the meaning, and replace the number with it.

* Encapsulate Field: There is a public field. Make it private and provide accessors. (O)

* Encapsulate Collection: A method returns a collection. Make it return a copy of the collection (J: collection.dup) and provide add/remove methods.

    Often a class contains a collection of instances. This collection might be an Array or a Hash. Such cases often have the usual attribute reader and writer for the collection. However, collections should use a protocol slightly different from that for other kinds of data. The attribute reader should not return the collection object itself, because that allows clients to manipulate the contents of the collection without the owning class knowing what is going on. It also reveals too much to clients about the object’s internal data structures. An attribute reader for a multivalued attribute should return something that prevents manipulation of the collection and hides unnecessary details about its structure. In addition there should not be an attribute writer for the collection: rather, there should be operations to add and remove elements. This gives the owning object control over adding and removing elements from the collection. With this protocol the collection is properly encapsulated, which reduces the coupling of the owning class to its clients.

* Replace Record with Data Class: You need to interface with a record structure in a traditional programming environment. Make a dumb data object for the record.

* Replace Type Code with Class: A class has a numeric type code that does not affect its behavior. Replace the number with a new class. (O) (J: this looks like a bad refactoring)

* Replace Type Code with Subclasses: You have an immutable type code that affects the behavior of a class. Replace the type code with subclasses. (O)

* Replace Type Code with Polymorphism: You have a type code that affects the behavior of a class. Replace the type code with classes: one for each type code variant. (R)

    There are three different refactorings to consider when you’re trying to remove conditional logic: Replace Type Code with Polymorphism, Replace Type Code with Module Extension, or Replace Type Code with State/Strategy. The choice depends on relatively subtle design differences.

    If the methods that use the type code make up a large portion of the class, I use Replace Type Code with Polymorphism. It’s the simplest, and just takes advantage of Ruby’s duck-typing to remove the conditional statements. It involves blowing away the original class and replacing it with a new class for each type code. Since the original class was heavily reliant on the type code, it generally makes sense for the clients of the original class to construct an instance of one of the new type classes (because they were probably injecting the type into the original class anyway).

    If the class has a large chunk of behavior that doesn’t use the type code, I choose either Replace Type Code with Module Extension or Replace Type Code with State/Strategy. These have the advantage of enabling me to change the type at runtime. In the former we extend a module, mixing in the module’s behavior onto the object. Instance variables are shared automatically between the object and the module, which can simplify things. Replace Type Code with State/Strategy uses delegation: The parent object delegates to the state object for state-specific behavior. The state object can be swapped out at runtime when a change in behavior is required. Because of the delegation, sharing of instance variables between the parent object and the state object can be awkward. So the question becomes, why would you choose State/Strategy over Module Extension? It turns out that you can’t unmix a module in Ruby, so removing undesired behavior can be difficult. When the state changes become complex enough that unwanted behavior cannot be removed or overridden, I choose Replace Type Code with State/Strategy.

    The great thing about Ruby is that you can do Replace Type Code with Polymorphism without inheritance or implementing an interface.

* Replace Type Code with Module Extension: You have a type code that affects the behavior of a class. Replace the type code with dynamic module extension. (R)

* Replace Type Code with State/Strategy: You have a type code that affects the behavior of a class and the type code changes at runtime. Replace the type code with a state object.

* Replace Subclass with Fields: You have subclasses that vary only in methods that return constant data. Change the methods to superclass fields and eliminate the subclasses.

    You create subclasses to add features or allow behavior to vary. One form of variant behavior is the constant method [Beck]. A constant method is one that returns a hard-coded value. This can be useful on subclasses that return different values for an accessor. You define the accessor in the superclass and override it with different values on the subclass. Although constant methods are useful, a subclass that consists only of constant methods is not doing enough to justify its existence. You can remove such subclasses completely by putting fields in the superclass. By doing that you remove the extra complexity of the subclasses.

* Lazily Initialized Attribute: Initialize an attribute on access instead of at construction time. (R) (J: ||=)

    Using ||= for Lazily Initialized Attributes is a common idiom; however, this idiom falls down when nil or false are valid values for the attribute. Use instance_variable_defined? then.

* Eagerly Initialized Attribute: Initialize an attribute at construction time instead of on the first access. (R) (J: I prefer eager loading in most place)

    The motivation for converting attributes to be eagerly initialized is for code readability purposes. Lazily initialized attributes change their value upon access. Lazily initialized attributes can be problematic to debug because their values change upon access. Eagerly Initialized Attributes initialize their attributes in the constructor of the class. This leads to encapsulating all initialization logic in the constructor and consistent results when querying the value of the instance variable.

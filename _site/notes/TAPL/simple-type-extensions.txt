Base Types
----------

Every programming language provides a variety of base types - sets of simple, unstructured values such as numbers, booleans, or characters - plus appropriate primitive operations for manipulating these values.

For theoretical purposes, it is often useful to abstract away from the details of particular base types and their operations, and instead simply suppose that our language comes equipped with some set A of uninterpreted or unknown base types, with no primitive operations on them at all. A can be thought of as standing for atomic types.


The Unit Type
-------------

Unit is a singleton type interpreted in the simplest possible way: we explicitly introduce a single element - the term constant unit (written with a small u) - and a typing rule making unit an element of Unit. We also add unit to the set of possible result values of computations - indeed, unit is the only possible result of evaluating an expression of type Unit.

Even in a purely functional language, the type Unit is not completely without interest, but its main application is in languages with side effects, such as assignments to reference cells. In such languages, it is often the side effect, not the result, of an expression that we care about; Unit is an appropriate result type for such expressions.

This use of Unit is similar to the role of the void type in languages like C and Java. The name void suggests a connection with the empty type Bot, but the usage of void is actually closer to our Unit.

Unit                            extends lambda
----------------------------------------------
t ::= ...                       terms
      unit                      constant unit

v ::= ...                       values
      unit                      constant unit

T ::= ...                       types
      Unit

Г |- unit:Unit                  (T-UNIT)

New derived forms
t1; t2 => (λx:Unit.t2) t1 where x not belongs to FV(t2)


Sequencing is a derived form (theorem)
--------------------------------------

Write λE ("E" for external language) for the simply typed lambda-calculus with the Unit type, the sequencing construct, and the rules E-SEQ, E-SEQNEXT, and T-SEQ, and λI ("I" for internal language) for the simply typed lambda-calculus with Unit only. Let e <- λE -> λI be the elaboration function that translates from the external to the internal language by replacing every occurrence of t1 ; t2 with (λx:Unit.t2) t1, where x is chosen fresh in each case. Now, for each term t of λE, we have

    * t ->E t′ iff e(t) ->I e(t′)
    * Г |-E t:T iff Г |-I e(t):T

where the evaluation and typing relations of λE and λI are annotated with E and I, respectively, to show which is which.

The advantage of introducing features like sequencing as derived forms rather than as full-fledged language constructs is that we can extend the surface syntax (i.e., the language that the programmer actually uses to write programs) without adding any complexity to the internal language about which theorems such as type safety must be proved.

Derived forms are often called syntactic sugar, following Landin. Replacing a derived form with its lower-level definition is called desugaring.

Another derived form that will be useful in examples later on is the "wild-card" convention for variable binders. It often happens (for example, in terms created by desugaring sequencing) that we want to write a "dummy" lambda-abstraction in which the parameter variable is not actually used in the body of the abstraction. In such cases, it is annoying to have to explicitly choose a name for the bound variable; instead, we would like to replace it by a wildcard binder, written _. That is, we will write λ_:S.t to abbreviate λx:S.t, where x is some variable not occurring in t.


Ascription
----------

Ascription is the ability to explicitly ascribe a particular type to a given term (i.e., to record in the text of the program an assertion that this term has this type). We write "t as T" for "the term t, to which we ascribe the type T."

as                              extends lambda
----------------------------------------------
t ::= ...                       terms
      t as T                    ascription

v1 as T -> v1                   E-ASCRIBE

t1 -> t1'
-------------------             E-ASCRIBE1
t1 as T -> t1' as T

Г |- t1:T
--------------                  T-ASCRIBE
Г |- t1 as T:T

There are a number of situations where ascription can be useful in programming. One common one is documentation. It can sometimes become difficult for a reader to keep track of the types of the subexpressions of a large compound expression. Judicious use of ascription can make such programs much easier to follow. Similarly, in a particularly complex expression, it may not even be clear to the writer what the types of all the subexpressions are. Sprinkling in a few ascriptions is a good way of clarifying the programmer's thinking. Indeed, ascription is sometimes a valuable aid in pinpointing the source of puzzling type errors.

Another use of ascription is for controlling the printing of complex types.  A final use of ascription is for abstraction. In systems where a given term t may have many different types (for example, systems with subtyping), ascription can be used to "hide" some of these types by telling the typechecker to treat t as if it had only a smaller set of types. (the relation between ascription and casting will be discussed later)


Let Binding
-----------

it is often useful-both for avoiding repetition and for increasing readability-to give names to some of its subexpressions. 

let                             extends lambda
----------------------------------------------
t ::= ...                       terms
      let x = t1 in t2          let binding

let x = v1 in t2 -> [x->v1]t2   E-LETV

t1 -> t1'
--------------------------------------    E-LET
let x = t1 in t2 ->  let x = t1' in t2

Г |- t1:T1    Г,x:T1 |- t2:T2
-----------------------------   T-LET
Г |- let x = t1 in t2:T2

We can define let binding as derived form too:

let x = t1 in t2 => (λx:T1.t2)t1

But notice that the right-hand side of this abbreviation includes the type annotation T1, which does not appear on the left-hand side. We discover the needed type annotation simply by calculating the type of t1. More formally, what this tells us is that the let constructor is a slightly different sort of derived form than the ones we have seen up till now: we should regard it not as a desugaring transformation on terms, but as a transformation on typing derivations.


Pairs
-----

x                               extends lambda
----------------------------------------------
t ::= ...                       terms
      {t,t}                     pair
      t.1                       first projection
      t.2                       second projection

v ::= ...                       values
      {v,v}                     pair value

T ::= ...                       types
      T1xT2                     product type

{v1,v2}.1 -> v1                 E-PAIRBETA1

{v1,v2}.2 -> v2                 E-PAIRBETA2

t1 -> t1'
-------------                   E-PROJ1
t1.1 -> t1'.1

t1 -> t1'
-------------                   E-PROJ2
t1.2 -> t1'.2

t1 -> t1'
-------------------             E-PAIR1
{t1,t2} -> {t1',t2}

t2 -> t2'
-------------------             E-PAIR2
{v1,t2} -> {v1,t2'}

Г |- t1:T1  Г |- t2:T2
----------------------          T-PAIR
Г |- {t1,t2}:T1xT2

Г |- t1:T11xT12
---------------                 T-PROJ1
Г |- t1.1:T11 

Г |- t1:T11xT12
---------------                 T-PROJ2
Г |- t1.2:T12


Tuples
------

It is easy to generalize the binary products (pairs) to n-ary products, often called tuples. The only cost of this generalization is that, to formalize the system, we need to invent notations for uniformly describing structures of arbitrary arity; such notations are always a bit problematic, as there is some inevitable tension between rigor and readability. We write {ti,i<-1..n} for a tuple of n terms, t1 through tn, and {Ti,i<-1..n} for its type. Note that n here is allowed to be 0; in this case, the range 1..n is empty and {ti,i<-1..n} is {}, the empty tuple. Also, note the difference between a bare value like 5 and a one-element tuple like {5}: the only operation we may legally perform on the latter is projecting its first component.

{}                              extends lambda
----------------------------------------------
t ::= ...                       terms
      {ti,i<-1..n}              tuple
      t.i                       projection

v ::= ...                       values
      {vi,i<-1..n}              tuple value

T ::= ...                       types
      {Ti,i<-1..n}

{vi,i<-1..n}.j -> vj            E-PROJTUPLE

t1 -> t1'
-------------                   E-PROJ
t1.i -> t1'.i

tj -> tj'
---------------------------------------------------------------------    E-TUPLE
{vi,i<-1..j-1, tj, tk,k<-j+1..n} -> {vi,i<-1..j-1, tj', tk,k<-j+1..n}

for each i  Г |- ti:Ti
------------------------------  T-TUPLE
Г |- {ti,i<-1..n}:{Ti,i<-1..n}

Г |- t1:{Ti,i<-1..n}
--------------------            T-PROJ
Г |- t1.j:Tj


Records
-------

{}                              extends lambda
----------------------------------------------
t ::= ...                       terms
      {li=ti,i<-1..n}           record
      t.l                       projection

v ::= ...                       values
      {li=vi,i<-1..n}           record value

T ::= ...                       types
      {li:Ti,i<-1..n}           record type

{li=vi,i<-1..n}.lj -> vj        E-PROJRCD

t1 -> t1'
-------------                   E-PROJ
t1.l -> t1'.l

tj -> tj'
--------------------------------------------------------------------------------------        E-RCD
{li=vi,i<-1..j-1, lj=tj, lk=tk,k<-j+1..n} -> {li=vi,i<1..j-1, lj=tj', lk=tk,k<-j+1..n}

for each i  Г |- ti:Ti
------------------------------------        T-RCD
Г |- {li=ti,i<-1..n}:{li:Ti,i<-1..n}

Г |- t1:{li:Ti,i<-1..n}
-----------------------                     T-PROJ
Г |- t1.lj:Tj

Note that the same "feature symbol," {}, appears in the list of features on the upper-left corner of the definitions of both tuples and products. Indeed, we can obtain tuples as a special case of records, simply by allowing the set of labels to include both alphabetic identifiers and natural numbers. Then when the ith field of a record has the label i, we omit the label. For example, we regard {Bool,Nat,Bool} as an abbreviation for {1:Bool,2:Nat,3:Bool}. (This convention actually allows us to mix named and positional fields, writing {a:Bool,Nat,c:Bool} as an abbreviation for {a:Bool,2:Nat,c:Bool}, though this is probably not very useful in practice.) In fact, many languages keep tuples and records notationally distinct for a more pragmatic reason: they are implemented differently by the compiler.

Programming languages differ in their treatment of the order of record fields. In many languages, the order of fields in both record values and record types has no affect on meaning - i.e., the terms {partno=5524,cost=30.27} and {cost=30.27,partno=5524} have the same meaning and the same type, which may be written either {partno:Nat,cost:Float} or {cost:Float, partno:Nat}. Our presentation chooses the other alternative: {partno=5524,cost=30.27} and {cost=30.27,partno=5524} are different record values, with types {partno:Nat,cost:Float} and {cost:Float, partno:Nat}, respectively.

Subtyping
=========

Subtyping is a very fundamental extension, sometimes called subtype polymorphism. Unlike the features we have studied up to now, which could be formulated more or less orthogonally to each other, subtyping is a cross-cutting extension, interacting with most other language features in non-trivial ways. Subtyping is characteristically found in object-oriented languages and is often considered an essential feature of the object-oriented style. 

Extends lambda with record ({}) and subtyping (<:)
----------------------------------------------
t ::=                          terms
      x                        variable
      λx:T.t                   abstraction
      t t                      application
      {li=ti,i<-1..n}          record
      t.l                      projection

v ::=                          values
      λx:T.t                   abstraction value
      {li=vi,i<-1..n}          record value

T ::=                          types
      Top                      maximum type
      Bot                      minimum type
      T->T                     type of functions
      {li:Ti,i<-1..n}          type of records

Г ::=                          contexts
      /                        empty context
      Г,x:T                    term variable binding

Evaluation                     t -> t'

t1 -> t1'
---------------                E-APP1
t1 t2 -> t1' t2

t2 -> t2'
---------------                E-APP2
v1 t2 -> v1 t2'

(λx:T11.t12)v2 -> [x -> v2]t12 E-APPABS

{li=vi,i<-1..n}.lj -> vj       E-PROJRCD

t1 -> t1'
-------------                  E-PROJ
t1.l -> t1'.l

tj -> tj'
-----------------------------------------------------------------------------------------    E-RCD
{li=vi,i<-1..j-1,  lj=tj,  lk=tk,k<-j+1..n} -> {li=vi,i<-1..j-1, lj=tj', lk=tk,k<-j+1..n}

Subtyping                      S <: T

S <: S                         S-REFL

S <: U    U <: T
----------------               S-TRANS
S <: T

S <: Top                       S-TOP

Bot <: S                       S-BOT

T1 <: S1    S2 <: T2
--------------------           S-ARROW
S1->S2 <: T1->T2

{li:Ti,i<-1..n+k} <: {li:Ti,i<-1..n}    S-RCDWIDTH

for each i Si <: Ti
----------------------------------    S-RCDDEPTH
{li:Si,i<-1..n} <: {li:Ti,i<-1..n}

{kj:Sj,j<-1..n} is a permutation of {li:Ti,i<-1..n}
---------------------------------------------------    S-RCDPERM
{kj:Sj,j<-1..n} <: {li:Ti,i<-1..n}

Typing                         Г |- t:T

x:T belongs to Г
----------------               T-VAR
Г |- x:T

Г,x:T1 |- t2:T2
--------------------           T-ABS
Г |- λx:T1.t2:T1->T2

Г |- t1:T11->T12    Г |- t2:T11
-------------------------------    T-APP
Г |- t1 t2:T12

Г |- t:S    S <: T
------------------             T-SUB
Г |- t:T

for each i Г |- ti:Ti
------------------------------------    T-RCD
Г |- {li=ti,i<-1..n}:{li:Ti,i<-1..n}

Г |- t1:{li:Ti,i<-1..n}
-----------------------        T-PROJ
Г |- t1.lj:Tj


Subsumption
-----------

The goal of subtyping is to 'loose' the typing rules. We accomplish this by formalizing the intuition that some types are more informative than others: we say that S is a subtype of T, written S <: T (T is a supertype of S), to mean that any term of type S can safely be used in a context where a term of type T is expected. This view of subtyping is often called the principle of safe substitution.

A simpler intuition is to read S <: T as "every value described by S is also described by T," that is, "the elements of S are a subset of the elements of T (T-SUB).


Subtype Relation
----------------

The subtype relation is formalized as a collection of inference rules for deriving statements of the form S <: T, We consider each form of type (function types, record types, etc.) separately; for each one, we introduce one or more rules formalizing situations when it is safe to allow elements of one type of this form to be used where another is expected.

We have two general stipulations: S-REFL (subtyping should be reflexive) and S-TRANS (subtyping should be transitive). These rules follow directly from the intuition of safe substitution.


For record types, we have

  {li:Ti,i<-1..n+k} <: {li:Ti,i<-1..n}    (S-RCDWIDTH, width subtyping)

  for each i Si <: Ti
  ----------------------------------    (S-RCDDEPTH, depth subtyping)
  {li:Si,i<-1..n} <: {li:Ti,i<-1..n}

  {kj:Sj,j<-1..n} is a permutation of {li:Ti,i<-1..n}
  ---------------------------------------------------    (S-RCDPERM)
  {kj:Sj,j<-1..n} <: {li:Ti,i<-1..n}

It may seem surprising that the "smaller" type-the subtype-is the one with more fields. The easiest way to understand this is regarding a record type {x:Nat} as describing "the set of all records with at least a field x of type Nat". So a longer record constitutes a more demanding-i.e., more informative-specification, and so describes a smaller set of values.

S-RCDPERM arises from the observation that the order of fields in a record does not make any difference to how we can safely use it, since the only thing that we can do with records once we've built them-i.e., projecting their fields-is insensitive to the order of fields.

S-RCDWIDTH, S-RCDDEPTH, and S-RCDPERM each embody a different sort of flexibility in the use of records. For purposes of discussion, it is useful to present them as three separate rules. In particular, there are languages that allow some of them but not others; for example, most variants of Abadi and Cardelli's object calculus (1996) omit width subtyping. However, for purposes of implementation it is more convenient to combine them into a single macro-rule that does all three things at once.


For function types, we have

  T1 <: S1    S2 <: T2
  --------------------    (S-ARROW)
  S1->S2 <: T1->T2

Notice that the sense of the subtype relation is reversed (contravariant) for the argument types in the left-hand premise, while it runs in the same direction (covariant) for the result types as for the function types themselves. The intuition is that, if we have a function f of type S1->S2, then we know that f accepts elements of type S1; clearly, f will also accept elements of any subtype T1 of S1. The type of f also tells us that it returns elements of type S2; we can also view these results belonging to any supertype T2 of S2. That is, any function f of type S1->S2 can also be viewed as having type T1->T2.

An alternative view is that it is safe to allow a function of one type S1->S2 to be used in a context where another type T1->T2 is expected as long as none of the arguments that may be passed to the function in this context will surprise it (T1 <: S1) and none of the results that it returns will surprise the context (S2 <: T2).


Finally, it is convenient to have a type that is a supertype of every type. We introduce a new type constant Top, plus a rule that makes Top a maximum element of the subtype relation (S-TOP). Note that the presence of the reflexivity and transitivity rules means that the subtype relation is clearly a preorder; however, because of the record permutation rule, it is not a partial order: there are many pairs of distinct types where each is a subtype of the other. The maximal type Top is not a necessary part of the simply typed lambda-calculus with subtyping; it can be removed without damaging the properties of the system. However, it is included in most presentations, for several reasons. First, it corresponds to the type Object found in most object-oriented languages. Second, Top is a convenient technical device in more sophisticated systems combining subtyping and parametric polymorphism.

It is natural to ask whether we can also complete the subtype relation with a minimal element—a type Bot that is a subtype of every type. The answer is that we can: see T-BOT and S-BOT. The first thing to notice is that Bot is empty - there are no closed values of type Bot. If there were one, say v, then the subsumption rule plus S-Bot would allow us to derive |- v:Top->Top, from which the canonical forms lemma tells us that v must have the form λx:S1.t2 for some S1 and t2. On the other hand, by subsumption, we also have |- v:{}, from which the canonical forms lemma tells us that v must be a record. The syntax makes it clear that v cannot be both a function and a record, and so assuming that |- v:Bot has led us to a contradiction. The emptiness of Bot does not make it useless. On the contrary: Bot provides a very convenient way of expressing the fact that some operations (in particular, throwing an exception or invoking a continuation) are not intended to return. Giving such expressions the type Bot has two good effects: first, it signals to the programmer that no result is expected (since if the expression did return a result, it would be a value of type Bot); second, it signals to the typechecker that such an expression can safely be used in a context expecting any type of value. For example, if the exception-raising term error is given type Bot, then a term like

   λx:T.
     if <check that x is reasonable> then
       <compute result>
     else
       error

will be well typed because, no matter what the type of the normal result is, the term error can always be given the same type by subsumption, so the two branches of the if are compatible, as required by T-If. Unfortunately, the presence of Bot significantly complicates the problem of building a typechecker for the system. A simple typechecking algorithm for a language with subtyping needs to rely on inferences like "if an application t1 t2 is well typed, then t1 must have an arrow type." In the presence of Bot, we must refine this to "if t1 t2 is well typed, then t1 must have either an arrow type or type Bot". So adding Bot is a more serious step than adding Top.

In languages with polymorphism, such as ML, we can also use "X.X as a result type for error and similar constructs. This achieves the same effect as Bot by different means: instead of giving error a type that can be promoted to any type, we give it a type scheme that can be instantiated to any type. Though they rest on different foundations, the two solutions are quite similar: in particular, the type "X.X is also empty.

Properties of Subtyping and Typing
----------------------------------

* Inversion of the Subtype Relation Lemma

  1. If S <: T1->T2, then S has the form S1->S2, with T1 <: S1 and S2 <: T2.
  2. If S <: {li:Ti,i<-1..n}, then S has the form {kj:Sj,j<-1..m}, with at least the labels {li,i<-1..n} - i.e., {li,i<-1..n} included by {kj,j<-1..m} - and with Sj <: Ti for each common label li = kj.

* Lemma

  1. If Г |- λx:S1.s2:T1->T2, then T1 <: S1 and Г, x:S1 |- s2:T2.
  2. If Г |- {ka=sa,a<-1..m}:{li:Ti,i<-1..n}, then {li,i<-1..n} included by {ka,a<-1..m} and Г |- sa:Ti for each common label ka = li.

* Substitution Lemma: If Г, x:S |- t:T and Г |- s:S, then Г |- [x|->s]t:T.

** Preservation Theorem: If Г |- t:T and t -> t′, then Г |- t′:T.

* Canonical Forms Lemma

  1. If v is a closed value of type T1->T2, then v has the form λx:S1.t2.
  2. If v is a closed value of type {li:Ti,i<-l..n}, then v has the form {kj=vj,j<-l..m}, with {li,i<-l..n} included by {kj,j<-l..m}.

** Progress Theorem: If t is a closed, well-typed term, then either t is a value or else there is some t′ with t -> t′.


The Top and Bottom Types
------------------------


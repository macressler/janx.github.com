============================= Agile Estimating and Planning ============================= 

================================
Part I. The Problem and The Goal
================================


1. The Purpose of Planning
==========================

A good planning process supports yourt project by:

  * Reducing risk 

    find risks at the very beginning

  * Reducing uncertainty 

    understand what a user want better

  * Supporting better decision making

  * Establishing trust

    Frequent reliable delivery of promised features builds trust between the developers of a product and the customers of that product. Reliable estimates enable reliable delivery.
    Reliable estimates benefit developers by allowing them to work at a sustainable pace. This leads to higher quality code and fewer bugs. These, in turn, lead back to more reliable estimates because less time is spent on highly unpredictable work such as bug fixing.

  * Conveying information

    A plan conveys expectations and describes one possibility of what may come to pass over the course of a project. A plan does not guarantee an exact set of features on an exact date at a specified cost. A plan does, however, communicate and establish a set of baseline expectations.


A good plan is one that stakeholders find sufficiently reliable that they can use it as the basis for making decisions. 

e.g. You'll ship a new release six months later. You create a plan that describes a set of features that are certain to be in the new version and another set of features that may or may not be included, depending on how well things progress.

A plan, although inaccurate, was even more likely useful if we consider that it should have been updated regularly throughout the course of the project. In that case, a one-month late delivery should not have been a last-minute surprise to anyone.

This book is about agile planning, not agile plans. Plans are documents or figures, they are snapshots of how we believe a project might unfold over an uncertain future. Planning is an activity. Agile planning shifts the emphasis from the plan to the planning. Agile planning balances the effort and investment in planning with the knowledge that we will revise the plan through the course of the project. An agile plan is one that we are not only willing but anxious to change. We don’t want to change the plan just for the sake of changing, but we want to change because change means we’ve learned something or that we’ve avoided a mistake.

Just because we’re changing the plan does not mean we change the dates.  We may or may not do that. But if we learn we were wrong about some aspect of the target product and need to do something about it, then the plan needs to change. There are many ways we can change the plan without changing the date.  We can drop a feature, we can reduce the scope of a feature, we can possibly add people to the project, and so on.

Because we acknowledge that we cannot totally define a project at its outset, it is important that we do not perform all of a project’s planning at the outset.  Agile planning is spread more or less evenly across the duration of a project. Release planning sets the stage and is followed by a number of rounds of iteration planning, after which the entire process is repeated perhaps a handful of times on a project.

So in defining agile planning we find that it:

  * Is focused more on the planning than the plan
  * Encourages change
  * Results in plans that are easily changed
  * Is spread throughout the project

Estimates given early in a project are far less accurate than those given later. This progressive refinement is shown in the cone of uncertainty.


2. Why Planning Fails
=====================

* 2/3 traditional projects cost more than plan
* 2/3 features in a released product is not need
* 100% traditional projects exceeds its schedule

Planning Is By Activity Rather Than Feature
-------------------------------------------

1. Activities Don't Finish Early:

"Work expands so as to fill the time available for its completion." - Parkinson’s Law (1957)

Parkinson is saying that we take as much time to complete an activity as we think we’ll be allowed. If there’s a Gantt chart hanging on the wall that says an activity is expected to take five days then the programmer assigned to that activity will generally make sure the activity takes the full five days. She may do this by adding a few bells and whistles if it looks like she’ll finish early (a practice known as gold-plating). Or, she may split time between the activity and researching some hot, new technology she thinks may be useful. What she will not do very often is finish the activity early. In many organizations, if she finishes early, her boss may accuse her of having given a padded estimate. Or, her boss may expect her to finish more activities early. Why risk either of these scenarios when a little web surfing can make the activity come in on schedule instead?

2. Lateness Is Passed Down the Schedule

An early start requires a combination of things to go well, a late start can be caused by one thing going wrong.

The problem is compounded because we’ve already established that activities will rarely finish early. This means that activities will start late and that the lateness will get passed down the schedule. 

3. Activities Are Not Independent

Many activities in a typical project plan are not independent. When an activity takes longer than planned, all similar activities are also likely to take longer than planned.


Multitasking Causes Further Delays
----------------------------------

A second reason why traditional approaches to planning often fail is multitasking, which is defined as simultaneously working on multiple tasks. Multitasking exacts a horrible toll on productivity. Clark and Wheelwright (1993) studied the effects of multitasking and found that the time an individual spends on value-adding work drops rapidly when the individual is working on more than two tasks. 

Multitasking becomes a problem on a traditionally planned project for two primary reasons. First, work is typically assigned well in advance of when the work will begin and it is impossible to efficiently allocate work in advance. As signing work to individuals rather than to groups exacerbates the problem. Second, it encourages focusing on achieving a high level of utilization of all individuals on the project rather than on maintaining sufficient slack to cope with the inherent variability in typical project tasks. Loading everyone to 100% of capacity has the same effect as loading a highway to 100% of capacity: no one can make any forward progress.


Features Are Not Developed By Priority
--------------------------------------

Many traditional plans are created with the assumption that all identified activities will be completed. This means that work is typically prioritized and sequenced for the convenience of the development team.

Traditional thinking says that if all work will be completed then project customers have no preference about the sequence in which that work is done. This leads to the development team working on features in what appears to the customer as a relatively haphazard order. Then, with the end of the project approaching, the team scrambles to meet the schedule by dropping features. Since there was no attempt to work on features in a priority order, some of the features dropped are of greater value than those that are delivered.


We Ignore Uncertainty
---------------------

A fourth shortcoming with traditional approaches to planning is the failure to acknowledge uncertainty. We ignore uncertainty about the product and assume that the initial requirements analysis led to a complete and perfect specification of the product. We assume that users will not change their minds, refine their opinions, or come up with new needs during the period covered by the plan.

Similarly, we ignore uncertainty about how we will build the product and pretend we can assign precise estimates (“2 weeks”) to imprecise work. As stated earlier in this chapter, we cannot hope to identify every activity that will be needed in the course of a project. Yet we often fail to acknowledge this in the plans we create.

Even with all this uncertainty, schedules are often expressed as a single, unqualified date: “We will ship on June 30,” for example. During the earliest part of a project we are the most uncertain. The estimates we give should reflect our uncertainty. One way of doing this is by expressing the end date as a range. “We’ll ship sometime between June and August,” for example. As the project progresses and as uncertainty and risk are removed from the project, estimates can be refined and made more precise.

The best way of dealing with uncertainty is to iterate. To reduce uncertainty about what the product should be, work in short iterations and show (or, ideally, give) working software to users every few weeks. Uncertainty about how to develop the product is similarly reduced by iterating. For example, missing tasks can be added to plans, bad estimates can be corrected, and so on. In this way, the focus shifts from the plan to the planning.


Estimates Become Commitments
----------------------------

Embedded within each and every estimate is a probability that the work will be completed in the estimated time. Suppose your team has been asked to develop a new high-end word processor. The probability of finishing this by the end of the week is 0%. The probability of finishing it in ten years is 100%. If I ask you for an estimate and you tell me the end of the week, that estimate comes with a probability of 0%. If the estimate you give me is ten years, that estimate comes with a probability of 100%. Each estimate between the end of the week and ten years from now comes with its own probability between 0% and 100% (Armour 2002).

A problem with traditional planning can arise if the project team or its stakeholders equate estimating with committing. As Phillip Armour (2002) points out, an estimate is a probability and a commitment cannot be made to a probability. Commitments are made to dates. Normally the date that a team is asked (or told) to commit to is one to which they would assign a less than 100% probability. Prior to making such a commitment the team needs to assess a variety of business factors and risks. It is important that they be given this opportunity and that every estimate does not become an implicit commitment.


3. An Agile Approach
====================


Agile Manifesto, Feb. 2001
--------------------------

* Individuals and interactions over processes and tools

Agile teams value individuals and interactions over processes and tools because they know that a well-functioning team of great individuals with mediocre tools will always outperform a dysfunctional team of mediocre individuals with great tools and processes. Great software is made by great individuals and as an industry we have tried too long with too little success to define a development process that relegates individuals to replaceable cogs in the machinery. Agile processes acknowledge the unique strengths (and weaknesses) of individuals and capitalize on these rather than attempting to make everyone homogeneous.

* Working software over comprehensive documentation

Agile teams value working software over comprehensive documentation because it leads them to have a stable, incrementally enhanced version of the product at the end of each iteration. This makes it possible to collect early, frequent feedback on both the product and the process. As the developed software grows each iteration it can be shown to likely or actual users. Feedback from these users is fed back into the development process to make sure that the team is always working on the highest-valued features and that those features will satisfy user expectations.

* Customer collaboration over contract negotiation

Customer collaboration is valued over contract negotiation because agile teams would like all parties to the project to be working toward the same set of goals. Contract negotiation sometimes sets the development team and the project customer at odds right from the start. I enjoy playing most games and when my oldest daughter was four, I bought her a “cooperative game” because it looked like a game she’d enjoy and because I had no idea how a cooperative game could be fun. In the game I bought her, a princess is placed under a spell and players need to remove obstacles (a moat, a locked door, and so on) that are between them and the princess. Players take turns as in most games but the goal is to collaboratively remove obstacles and save the princess. All players win or all players lose. The game is surprisingly fun and we’d like software teams and customers to approach projects with this same attitude of collaboration and shared goals. Yes, contracts are often necessary but the terms and details in a contract can exert great influence on whether the different parties are set on a collaborative or a competitive effort.

* Responding to change over following a plan

Agile teams value responding to change over following a plan because their ultimate focus is on delivering as much value as possible to the project’s customer and users. For all but the simplest projects, it is impossible for users to know every detail of every feature they want. It is inevitable that users will come up with new ideas and almost as inevitable that they will decide that some features desired today will become lower priorities tomorrow. To an agile team, a plan is one view of the future but many views are possible. As a team gains knowledge and experience they will factor these into the plan. Perhaps the team is progressing faster or slower than initially expected, perhaps users like one set of features more than expected but don’t like another feature that was initially considered critical.


An Agile Approach To Projects
-----------------------------

* Work as one team

Critical to the success of a project is that all project participants view themselves as one team aimed at a common goal. There is no room for a “throw it over the wall” mentality on an agile project. Analysts do not throw requirements over the wall to designers. Designers and architects do not throw designs over a wall to coders; coders do not throw half-tested code over a wall to testers. A successful agile team must have a we’re-all-in-this-together mindset. While an agile team should work together as one whole team, there are a number of specific roles on the team. It was worth identifying and clarifying those roles that play a part in agile estimating and planning.

The first role is the product owner. The primary duties of the product owner include making sure that all team members are purusing a common vision for the project, establishing priorities so that the highest-valued functionality is always being worked on, and making decisions that lead to a good return on the investment in the project. When developing commercial software, the product owner is often someone from the marketing or product management side of the company. When developing software for internal use, the product owner may instead be a user, the users’ manager, an analyst, or the person funding the project. (Raphael!)

A second role is that of customer. The customer is the person who has made the decision to fund the project or to buy the software. On a project developing software for internal use, the customer is usually a representative from another group or division. On such projects the product owner and customer roles are often combined. For a commercially distributed product, the customer will be the person who buys the software. In either case, the customer may or may not be a user of the software, which is, of course, another important role. (Raphael!)

Another role worth highlighting is that of developer. I use developer very generally to refer to anyone developing software. That includes programmers, testers, analysts, database engineers, usability experts, technical writers, architects, designers, and so on. Using this definition, even the product owner may be thought of as a developer on many projects. (Us!)

A final role is the project manager. As described by Highsmith (2004), the role of the project manager changes on agile projects. Agile project managers focus more on leadership than on management. On some agile projects, the person fufilling the project manager role will also act in another role, often as a developer but occasionally as a product owner. (Felix!)

* Work in short iterations

On an agile project there is no grand delineation of phases—no upfront requirements phase followed by analysis followed by architectural design and so on. Depending upon the actual agile process you select or define, you may put a very short design, modeling, or other phase at the front end of the project. But, once the project has begun in earnest, all work (requirements, design, coding, testing, and so on) happens concurrently within each iteration.

Iterations are timeboxed, meaning they finish on time even if functionality is dropped to do so, and are often very short. Most agile teams work in iterations of from one to four weeks long but some teams maintain their agility with iterations of up to three months. Most teams settle upon a relatively consistent iteration length. Some, however, choose the appropriate length for an iteration at the start of each iteration.

* Deliver something each iteration

More crucial than the specific iteration length chosen by a team is that during the iteration they transfrom one or more imprecise requirements statements into coded, tested, and potentially shippable software. Of course many teams will not deliver the results of every iteration to their users; the goal is simply that they could. This means that teams make progress by adding one or more small features in each iteration but that each added feature is coded, tested, and of releaseable quality.

It is essential that the product be brought to this potentially shippable state by the end of each iteration. Practically, this does not mean a team must do absolutely everything necessary to release since they often won’t release each iteration. For example, I work with one team that requires two months of mean time between failure (MTBF) testing before releasing their product, which includes both hardware and software. They cannot shorten those two months as it is contractually required by their client and that amount of time is often necessary to check for hardware failures. This team works in four-week iterations and apart from running this two-month MTBF test, their product is at a truly releasable state at the end of each iteration.

Because a single iteration does not usually provide sufficient time to complete enough new functionality to satisfy user or customer desires, the broader concept of a release is introduced. A release comprises one or more (usually more) iterations that build upon each other to complete a set of related functionality. While iterations are most commonly one to four weeks, a release is typically two to six months. For example, in an investment management system, one release may include all of the functionality related to buying and selling mutual funds and money market funds. This may take six two-week iterations to complete (roughly three months). A second release may add stock and bond trading and take four additional two-week iterations. Releases may occur at varying intervals. A first release may take six months to be developed. It may be followed by another release three months later, and so on.

* Focus on business priorities

Agile teams demonstrate a commitment to business priorities in two ways. First, they deliver features in the order specified by the product owner, who is expected to prioritize and combine features into a release that optimizes the return on the organization’s investment in the project. To achieve this, a release plan is created based on the team’s capabilities and a prioritized list of desired new features. In order for the product owner to have the most flexibility in prioritizing, features must be written so as to minimize the technical dependencies between them. It is difficult for a product owner to prioritize features into a release plan if the selection of one feature requires the prior development of three others. A team is unlikely to achieve a goal of absolutely no dependencies; however, keeping dependencies at a minimum is often quite feasible.

Second, agile teams focus on completing and delivering user-valued features rather than on completing isolated tasks (that eventually combine into a user-valued feature). One of the best ways to do this is to work with user stories, which are a lightweight technique for expressing software requirements. A user story is a brief description of functionality as viewed by a user or customer of the system. User stories are free-form and there is no mandatory syntax. However, it can be useful to think of a story generally fitting the form: “As a <type of user>, I want <capability> so that <business value>.” With this template as an example, you may have the story “As a book-buyer, I want to search for a book by ISBN so that I can find the right book quickly.”

User stories are lightweight because the work to gather and document them is not all done upfront. Rather than writing a lengthy requirements specification, agile teams have found it better to pursue to a just-in-time requirements approach. Typically this begins with a short description of a user story being handwritten on a note card, or perhaps typed into a computer for larger or distributed teams. The story card is just the beginning, though, and each user story is accompanied by as many conversations between the developers and the product owner as needed. These conversations happen as often as needed and include whoever is necessary. Written documentation may continue to exist when using a story-based requirements approach. However, the focus is shifted dramatically from written to verbal communication.

* Inspect and adapt

The plan created at the start of any project is not a guarantee of what will occur.  In fact, it is only a point-in-time guess. Many things will conspire to invalidate the plan — project personnel may come or go, technologies will work better or worse than expected, users will change their minds, competitors may force us to respond differently or more rapidly, and so on. Agile teams view every such change as presenting both the opportunity and need to update the plan in order to better reflect the reality of the current situation.

At the start of each new iteration, an agile team incorporates all new knowledge gained in the preceding iteration and adapts accordingly. If a team has learned something that is likely to affect the accuracy or value of the plan, they adjust the plan. The accuracy of the plan may be affected by the team discovering they have over- or underestimated their rate of progress. Or they may discover that a certain type of work is more time-consuming than previously thought.

The value of the plan may be altered by knowledge the product owner has gained about the desires of likely users. Perhaps, based on feedback from seeing the software from an earlier iteration, the product owner has learned that users would like to see more of one type of feature and that they don’t value another feature as much as was previously thought. The value of the plan could be increased in this case by moving more of the desired features into the release at the expense of some of the lesser-valued features.

None of this is to say that agile teams take an ad hoc view of changing priorities. Priorities do tend to be relatively stable from one iteration to the next.  However, the opportunity to alter priorities between iterations is a powerful contributor to the ability to maximize the return on the project investment.


An Agile Approach to Planning
-----------------------------

Estimating and planning the development of a new product is a daunting task made more difficult by our misconceptions about projects. Macomber (2004) points out that we should not view a project solely as the execution of a series of steps. Instead, it is important that we view a project as rapidly and reliably generating a flow of useful new capabilities and new knowledge. The new capabilities are delivered in the product, the new knowledge is used to make the product the best that it can be.

On an agile project, we use this flow of new capabilities and knowledge to guide the ongoing work. The new knowledge generated by the project may be about the product or the project. New product knowledge helps us know more about what the product should be. New project knowledge is information about the team, the technologies in use, the risks, and so on.

We frequently fail to acknowledge and plan for this new knowledge. Failing to plan to acquire new knowledge leads to plans built on the assumption that we know everything necessary to create an accurate plan. In the world of software development that is rarely, if ever, the case. Ward Cunningham has said that “it’s more planning what you want to learn, not what it [the product] will be in the end.” (Van Schooenderwoert 2004).

I often equate the traditional view of a project as running a 10-kilometer race. You know exactly how far away the finish line is and your goal is to reach it as quickly as possible. On an an agile project, we don’t know exactly where the finish line is but we often know we need to get to it or as close as we can by a known date. An agile project is more like a timed race than a 10-kilometer race: run as far as possible in sixty minutes. In this way, the agile project team knows when it will finish, but not what they will deliver. When we acknowledge that the end result is both somewhat unknown as well as unknowable in advance, plan- ning becomes a process of setting and revising goals that lead to a longer term objective.

* Multiple Levels of Planning

When setting and revising goals, it is important to remember that we cannot see past the horizon and that the accuracy of a plan decreases rapidly the further we attempt to plan beyond where we can see. For example, suppose you are standing on a small boat and that your eyes are nine feet above the water. The distance to the horizon in this case is slightly over four miles.1 If you are planning a twenty mile trip, you should plan on looking ahead at least five times, once every four miles. Because you cannot see past the horizon, you need to look up often and adjust your plan. A project is at risk if its planning extends well beyond the planner’s horizon and does not include time for the planner to raise her head, look at the new horizon, and make adjustments. A progressive elaboration of the plan is needed.

Agile teams achieve this by planning at three distinct horizons. The three horizons are the release, the iteration, and the current day. The relationships between these (and other) planning horizons can be seen in the planning onion of Figure below:

       Strategy
       Portfolio
       Product
-----  Release  -----
| --- Iteration --- |
| | ---- Day ---- | |
| | |           | | |
| | |           | | |
| | ------------- | |
- -------------------

Most agile teams are only concerned with the three innermost levels of the planning onion. Release planning considers the user stories or themes that will be developed for a new release of a product or system. The goal of release planning is to determine an appropriate answer to the questions of scope, schedule, and resources for a project. Release planning occurs at the start of a project but is not an isolated effort. A good release plan is updated throughout the project (usually at the start of each iteration) so that it always reflects the current expectations about what will be included in the release.

At the next level is iteration planning, which is conducted at the start of each iteration. Based on the work accomplished in the just-finished iteration, the product owner identifies high priority work the team should address in the new iteration. Because we are looking at a closer horizon than with release planning, the components of the plan can be smaller. During iteration planning we talk about the tasks that will be needed to transform a feature request into working and tested software.

Finally, there is daily planning. Most agile teams use some form of daily standup meeting to coordinate work and synchronize daily efforts. Although it may seem excessive to consider this planning in the formal sense, teams definitely make, assess, and revise their plans during these meetings. During their daily meetings, teams constrain the planning horizon to be no further away than the next day, when they will meet again. Because of this, they focus on the planning of tasks and on coordinating the individual activities that lead up to the completion of a task.

Outside the concern of most individual agile teams (and this book) are product, portfolio, and strategic planning. Product planning involves a product owner looking further ahead than the immediate release and planning for the evolution of the released product or system. Portfolio planning involves the selection of the products that will best implement a vision established through an organization’s strategic planning.

* Conditions of Satisfaction

Every project is initiated with a set of objectives. Your current project may be to create the world’s best word processor. Creating the world’s best word processor, however, will typically be only one objective for this project. There will almost certainly be additional objectives regarding schedule, budget, and quality. These objectives can be thought of as the the customer or product owner’s conditions of satisfaction; that is, the criteria that will be used to gauge the success of the project.

Way back when I was a high school and assigned to write a paper about a book such as Moby Dick I would always ask the teacher how long the paper had to be. She’d respond something like “five pages” and I then knew her primary condition of satisfaction. There were, of course, a number of additional, unwritten conditions of satisfaction such as that the paper would be well-written, my own work, in English, and so on.

At the start of release planning, the team and product owner collaboratively explore the product owner’s conditions of satisfaction. Common factors in her conditions of satisfaction include the usual items: scope, schedule, budget, and quality, although agile teams typically prefer to treat quality as non-negotiable.  The team and product owner look for ways to meet all of the conditions of satisfaction. The product owner may, for example, be equally satisfied with a release in five months that includes one set of user stories as with a release a month later that includes additonal user stories.

Sometimes, however, all of the product owner’s conditions of satisfaction cannot be met. The team can build her the world’s best word processor but they cannot build it by next month. When no feasible solution can be found, the conditions of satisfaction must change. Because of this, release planning and exploration of the product owner’s conditions of satisfaction are highly iterative.

Once a release plan covering approximately the next three to six months is established, it is used as input into the planning of the first iteration. Just as release planning began with consideration of the product owner’s conditions of satisfaction, so does iteration planning. For an iteration, the product owner’s conditions of satisfaction are typically the features she’d like developed next and some high-level tests about each feature.

As an example, consider a travel reservation site that includes the user story, “As a user, I want to be able to cancel a reservation.” In discussing this story with the product owner, the developers learn that her conditions of satisfaction for this story include that:

  A user who cancels more than 24 hours in advance gets a complete refund
  A user who cancels less than 24 hours in advance is refunded all but a $25 cancellation fee
  A cancellation code is displayed on the site and is emailed to the user

Like release planning, iteration planning is iterative. The product owner and the team discuss various ways of best meeting the conditions of satisfaction for the iteration.

Feedback loops from the resulting new product increment back into the conditions of satisfaction boxes at the start of both release and iteration planning. Based on their experience developing the product increment during the iteration the team may have gained knowledge or experience that affects planning at one or more of these levels. Similarly, showing the product increment to existing or likely users may generate new knowledge that may cause changes to the plans. An agile team will incorporate these changes into their plans to the extent they lead to a higher-value product.


========================
Part II. Estimating Size
========================

Agile teams separate estimates of size from estimates of duration. Estimates size first, then estimate duration. (Duration = Size/Velocity) We'll see two measures of size - story points and ideal time.


4. Estimating Size with Story Points
====================================


Story Points are Relative
-------------------------

Story points are a unit of measure for expressing the overall size of a user story, feature, or other piece of work. When we estimate with story points we assign a point value to each item. The raw value we assign is unimportant. What matters are the relative values. A story that is assigned a two should be twice as much as a story that is assigned a one. It should also be two-thirds of a story that is estimated as three story points.

The number of story points associated with a story represents the overall size of the story. There is no set formula for defining the size of a story. Rather, a story point estimate is an amalgamation of the amount of effort involved in developing the feature, the complexity of developing it, the risk inherent in it, and so on.

There are two common ways to get started. The first appoach is to select a story that you expect to be one of the smallest stories you’ll work with and say that story is estimated at 1 story point. The second approach is instead to select a story that seems somewhat medium-sized and give it a number somewhere in the middle of the range you expect to use. Personally, I prefer most of my stories to be in the range of 1–10. This means I’ll look for a medium-size story and call it five story points. Once you’ve fairly arbitrarily assigned a story point value to the first story, each additional story is estimated by comparing it to the first story or to any others that have been estimated.

On an agile project it is not uncommon to begin an iteration with incompletely specified requirements, the details of which will be discovered during the iteration. However, we need to associate an estimate with each story, even those that are incompletely defined. When you’re given a loosely-defined user story (or dog), you make some assumptions, take a guess, and move on. You can guess like this: "this won't be larger than A, which is 5 points; and will be larger than B, which 1-2 points. So give it an average, 3, will be reasonable"


Velocity
--------

In order to understand how estimating in unitless story points can possibly work, it is necessary to introduce a new concept: velocity. Velocity is a measure of a team’s rate of progress. It is calculated by summing the number of story points assigned to each user story that the team completed during the iteration. If the team completed three stories each estimated at five story points then their velocity would be fifteen. If the team completed two five-point stories their velocity would be ten.

If a team completed ten story points of work last iteration, our best guess is that they will complete ten story points this iteration. Since story points are estimates of relative size, this will be true whether they work on two five-point stories or five two-point stories. If we sum the story point estimates for all desired features we come up with a total size estimate for the project. If we know the team’s velocity we can divide size by velocity to arrive at an estimated number of iterations. We can turn this duration into a schedule by mapping it onto a calendar.

Fortunately, as a team begins making progress through the user stories of a project, their velocity becomes apparent over the first few iterations. The beauty of a points-based approach to estimating is that planning errors are self-correcting because of the application of velocity. The beauty of this is that estimating in story points completely separates the estimation of effort from the estimation of duration. Of course effort and schedule are related, but separating them allows each to be estimated independently. In fact you are no longer even estimating the duration of a project; you are computing it or deriving it. The distinction is subtle but important.


5. Estimating in Ideal Days
===========================

Ideal time is the amount of time that something takes when stripped of all peripheral activities. Elapsed time, on the other hand, is the amount of time that passes on a clock (or perhaps a calendar). It is almost always far easier and accurate to predict the duration of an event in ideal time than in elapsed time. 

On a software project, ideal time differs from elapsed time because of the natural overhead we experience every day. On any given day, in addition to working on the planned activities of a project, a team member may spend time answering email, making a support call to a vendor, interviewing a candidate for the open analyst position, and in two meetings. 

Additionally, in looking at why ideal time does not equal elapsed time, consider that managers are able to work an average of only five minutes between interruptions (Hobbs 1987). Even if the typical developer is interrupted only one-third as often that is still an interruption every fifteen minutes.

Problems can arise when a manager asks a team member the inevitable question: “How long will this take?” The team member responds “five days,” so the manager counts off five days on her calendar and marks the day with a big red X. The team member, however, really meant to say, “Five days if that’s all I do; but I do a lot of other things so probably two weeks.” On a software project, multitasking also broadens the gap between ideal time and elapsed time. A football player is never asked by his coach, “Since you’re not busy on every play, I want you to play in this high-priority hockey game at the same time.” A software developer who is told to multitask loses a great deal of efficiency while switching between two (or more) tasks.

On a software project, we may choose to estimate user stories or other work in ideal days. When estimating in ideal days you assume that:

  * the story being estimated is the only thing you’ll work on (single task)
  * everything you need will be on hand when you start (independent)
  * there will be no interruptions


When we estimate the number of ideal days that a user story will take to develop, test, and accept, it is not necessary to consider the impact of the overhead of the environment in which the team works. If developing a particular screen will take me one ideal day, then it will take me one ideal day regardless of whether I’m employed by a startup with no overhead or other demands on my team or by a huge bureaucracy. 

*** When considerations of organizational overhead are ignored, ideal days can be thought of as another estimate of size, just as story points are. Then, an estimate of size expressed as a number of ideal days can be converted into an estimate of duration using velocity in exactly the same way as with story points.  

If you choose to estimate in ideal days, assign one aggregate estimate to each user story. Some teams are tempted to estimate a number of ideal days for each individual or group who will work on a story. For example, such a team might estimate that a particular user story will take two ideal days from a programmer, one ideal day from a database engineer, one ideal day from a user interaction designer, and two ideal days from a tester. I’ve seen teams then write the estimate on the story card with either a different colored marker for each role or on a different colored sticky piece of paper for each role that is affixed to the story card.

In the vast majority of cases my advice is not to do this. This level of focus on the individual roles on a team shifts team thinking away from the “we’re all in this together” mentality we’d like to exist on an agile team. Further, it vastly increases the amount of work necessary to plan a release. If each story is assigned an estimate for each role who will work on the story then the release plan should realistically take each role into account. This means we’d have to track velocity and remaining work for each role as well.

While this is rarely worth the additional effort it may sometimes be necessary. I was with one client recently who is working on three versions of a product — one for the Macintosh, one for Windows, and one for handheld computers. In their case it is absolutely critical that each version be released with exactly the same functionality. Further, the individuals on this team do not currently have the skills to switch between Mac, Windows, and handheld development. A team in this situation may want to estimate the ideal time for each role on each story. They should, however, be aware of the extra administrative burden this will require.


6. Techniques for Estimating
============================

No matter how much effort is invested, the estimate is never at the top of the accuracy axis. No matter how much effort you put into an estimate, an estimate is still an estimate. No amount of additional effort will make an estimate perfect. It is possible to put too much effort into estimating with the result being a less accurate estimate.

Agile team acknowledge that we cannot eliminate uncertainty from estimates but they embrace the idea that small efforts are rewarded with big gains. Even though they are less far up the accuracy/effort scale, agile teams can produce more reliable plans because they deliver small increments of fully working, tested, integrated code.


Estimates are Shared
--------------------

Estimates are not created by a single individual on the team. Agile teams do not rely on a single expert to estimate. Despite well-known evidence that estimates prepared by those who will do the work are better than estimates prepared by anyone else (Lederer 1992), estimates are best derived collaboratively by the team, which includes those who will do the work.

First, on an agile project we tend not to know specifically who will perform a given task. Yes, we may all suspect that the team’s database guru will be the one to do the complex stored procedure task that has been identified. However, there’s no guarantee that this will be the case. She may be busy when the time comes and someone else will work on it. So, since anyone may work on anything, it is important that everyone have input into the estimate.

Second, even though we may expect the database guru to do the work, others may have something to say about her estimate. Suppose, for example, that the team’s database guru, Kristy, estimates a particular user story as three ideal days. Someone else on the project may not know enough to program the feature himself but he may know enough to say, “Kristy, you’re nuts; the last time you worked on a feature like that it took a lot longer. I think you’re forgetting how hard it was last time.” At that point Kristy may offer a good explanation of why it’s different this time. However, more often than not in my experience, she will acknowledge that she was indeed underestimating the feature.


The Estimation Scale
--------------------

Studies have shown that we are best at estimating things that fall within one order of magnitude (Miranda 2001; Saaty 1996). So you're good at esimating disance between your home and nearest shopping-mall, but not good at the distance between your home and the Moon.

Two good estimation scales:

  * 1, 2, 3, 5, 8 (fibonacci)
  * 1, 2, 4, 8 (exponetial)

These non-linear sequences work well because they reflect the greater uncertainty associated with estimates for larger units of work. Each of these numbers should be thought of as a bucket into which items of the appropriate size are poured. Rather than thinking of work as water being poured into the buckets, think of the work as sand. 

You may want to consider including 0 as a valid number within your estimation range. While it’s unlikely that a team will encounter many user stories or features that truly take no work, including 0 is often useful. There are two reasons for this. First, if we want to keep all features within a 10x range, assigning non-zero values to tiny features will limit the size of largest features. Second, if the work truly is closer to 0 than 1, the team may not want the completion of the feature to contribute to its velocity calculations. 

While, in general, we want to estimate user stories whose sizes are within one order of magnitude, this cannot always be the case. If we are to estimate everything within one order of magnitude it would mean writing all stories at a fairly fine-grained level. For features that we’re not sure we want (a preliminary cost estimate is desired before too much investment is put into them) or for features that may not happen in the near future, it is often desirable to write one much larger user story. A large user story is sometimes called an epic.

Additionally, a set of related user stories may be combined together (usually by a paper clip if working with note cards) and treated as a single entity for either estimating or release planning. Such a set of user stories is referred to as a theme. An epic, by its very size alone, is often a theme on its own. By aggregating some stories into themes and writing some stories as epics, a team is able to reduce the effort they’ll spend on estimating. However, it’s important that they realize that estimates of themes and epics will be more uncertain than estimates of the more specific, smaller user stories.

User stories that will be worked on in the near future (the next few iterations) need to be small enough that they can be completed in a single iteration. These items should be estimated within one order of magnitude. I use the sequence 1, 2, 3, 5, and 8 for this. User stories or other items that are likely to be more distant than a few iterations can be left as epics or themes. These items can be estimated in units beyond the 1–8 range I recommend. To accommodate estimating these larger items I add 13, 20, 40, and 100 to my preferred sequence of 1, 2, 3, 5, and 8.


Deriving an Estimate
--------------------

Three most common techniques may be used on its own but should be combined for best results when estimaing:

* Expert opinion

Ask an expert, and the expert gives an estimate based on his intuition. This approach is less useful on agile projects than on traditional projects. On an agile project, estimates are assigned to user stories or other user-valued functionality. Developing this functionality is likely to require a variety of skills normally performed by more than one person. This makes it difficult to find suitable experts who can assess the effort across all disciplines. On a traditional project for which estimates are associated with tasks this is not as significant of a problem because each task is likely performed by one person. Another benefit of this method is it's usually fast.

* Analogy

When estimating by analogy, the estimator compares the story being estimated to one or more other stories. If the story is twice the size, it is given an estimate twice as large. There is evidence that we are better at estimating relative size than we are at estimating absolute size.

When estimating this way you do not compare all stories against a single baseline or universal reference. Instead, you want to estimate each new story against an assortment of those that have already been estimated. This is referred to as triangulation. To triangulate, compare the story being estimated against a couple of other stories. To decide if a story should be estimated at five story points, see if it seems a little bigger than a story you estimated at three and a little smaller than a story you estimated at eight.

* Disaggregation

Disaggregation refers to splitting a story or feature into smaller, easier-to-estimate pieces.


Planning Poker
--------------

Planning poker combines expert opinion, analogy, and disaggregation into an enjoyable approach to estimating that results in quick but reliable estimates. Participants in planning poker include all of the developers on the team. The product owner participates in planning poker but does not estimate.

At the start of planning poker, each estimator is given a deck of cards. Each card has written on it one of the valid estimates. Each estimator may, for example, be given a deck of cards that read 0, 1, 2, 3, 5, 8, 13, 20, 40, and 100. The cards should be prepared prior to the planning poker meeting and the numbers should be large enough to see across a table. Cards can be saved and used for the next planning poker session. For each user story or theme to be estimated, a moderator reads the description. The moderator is usually the product owner or an analyst. However, the moderator can be anyone as there is no special privilege associated with the role. The product owner answers any questions that the estimators have. However, everyone is asked to remain aware of the effort/accuracy curve. The goal in planning poker is not to derive an estimate that will withstand all future scrutiny. Rather, the goal is to be somewhere well on the left of the effort line where a valuable estimate can be arrived at cheaply. After their questions are answered, each estimator privately selects a card representing his or her estimate. Cards are not shown until each estimator has made a selection. At that time, all cards are simultaneously turned over and shown so that all participants can see each estimate. It is very likely at this point that the estimates will differ significantly. This is actually good news. If estimates differ, the high and low estimators explain their estimates. It’s important that this does not come across as attacking those estimators. Instead, you want to learn what they were thinking about.

The group can discuss the story and their estimates for a few more minutes. The moderator can take any notes she thinks will be helpful when theis story is being programmed and tested. After the discussion, each estimator re-estimates by again selecting a card. Cards are once again kept private until everyone has estimated at which point they are turned over at the same time. In many cases, the estimates will already converge by the second round. But, if they have not, continue to repeat the process. The goal is for the estimators to converge on a single estimate that can be used for the story. It rarely takes more than three rounds but continue the process as long as estimates are moving closer together. It isn’t necessary that everyone in the room turn over a card with exactly the same estimate written down. If I’m moderating an estimate and on the second round four estimators tell me 5, 5, 5, and 3, I will ask the low estimator if she is OK with an estimate of 5. Again, the point is not absolute precision but reasonableness.

It is possible to play planning poker with a subset of the team, rather than involving everyone. This isn’t ideal but may be a reasonable option, especially if there are many, many items to be estimated as can happen at the start of a new project. The best way to do this is to split the larger team into two or three smaller teams each of which must have at least three estimators. It is important that each of the teams estimate consistently. What your team calls three story points or ideal days better be consistent with what my team calls the same. To achieve this, start all teams together in a joint planning poker game for an hour or so. Have them estimate 10–20 stories. Then make sure each team has a copy of these stories and their estimates and that they use them as baselines for estimating the stories they are given to estimate.

Teams will need to play planning poker at two different times. First, there will usually be an effort to estimate a large number of items before the project officially begins or during its first iterations. To estimate an initial set of user stories may take a team two or three meetings of from one to three hours. Naturally this will depend on how many items there are to estimate, the size of the team, and the product owner’s ability to succinctly clarify the requirements. Second, teams will need to put forth some ongoing effort to estimate any new stories that are identified during an iteration. One way to do this is to plan to hold a very short estimation meeting near the end of each iteration. Normally this is quite sufficient for estimating any work that came in during the iteration and it allows new work to be considered in the prioritization of the coming iteration.

Alternatively, colleague Kent Beck suggests hanging an envelope on the wall with all new stories placed in the envelope. As individuals have a few spare minutes they will grab a story or two from the envelope and estimate them. Teams will establish a rule for themselves, typically either that all stories must be estimated by the end of the day or by the end of the iteration. I like the idea of hanging an envelope on the wall to contain unestimated stories. However, I’d prefer that when someone has a few spare minutes to devote to estimating that he find at least one other person and that they estimate jointly.

* Planning poker brings together multiple expert opinions to do the estimating.
* A lively dialogue ensues during planning poker and estimators are called upon by their to justify their estimates. 
* Studies have shown that averaging individual estimates leads to better results as do group discussions of estimates.
* Planning poker works because it’s fun.


7. Re-Estimating
================

If we keep in mind that story points and ideal time estimate size then it’s easier to see that we should re-estimate only when we believe a story’s relative size has changed. When working with story points or ideal time we do not re-estimate solely because a story took longer to implement than we thought.

Velocity is the great equalizer. Because the estimate for each feature is made relative to the estimates for other features, it does not matter if our estimates are correct, a little incorrect, or a lot incorrect. What matters is that they are consistent.

I’m generally in favor of an all-or-nothing stance toward counting velocity: if a story is done (coded, tested, and accepted by the product owner) then the team earns all the points, but if anything on the story isn’t done, they earn nothing. At the end of an iteration, this is the easiest case to assess. This works well as long as everyone remembers that we’re mostly interested in the team’s average velocity over time, not in whether velocity jumped up or down in a given iteration.

In some cases the unfinished portion of a story may not be done in the next iteration. In these cases it can be appropriate to allow the team to take partial credit for the completed portion of the story. The remaining story (which is a subset of the initial story) is re-estimated based on the team’s current knowledge. 

Do not become overly concerned with the need to re-estimate. Whenever the team feels one or more stories are mis-estimated relative to other stories, re-estimate as few stories as possible to bring the relative estimates back in line.


8. Choosing Between Story Points and Ideal Days
===============================================

Why Story Points
----------------

* Story points help drive cross-functional behavior

* Story point estimates do not decay

  Note that both story point and ideal day estimates will need to be updated if the size of an effort changes based on the development of a framework, for example. However, only ideal day estimates need to change when the team the team becomes better at something. Velocity won't fix the problem with ideal days.

* Story points are a pure measure of size

  First, this means that we can only estimate story points by analogy. There is credible evidence that we are better at estimating “this is like that” than we are at estimating the absolute size of things (Lederer 1998; Vicinanza 1991). When we estimate in ideal days, on the other hand, we can still estimate by analogy. But, when estimating in ideal days we also tend to think of the calendar and how long a story will take to develop.

  Second, because story points are a pure measure of size and are entirely abstract there can be no temptation to compare them to reality. Teams that estimate in ideal days almost inevitably have their ideal days compared to actual days. They then find themselves justifying why they “only” completed eight ideal days of work in a ten-day iteration.

* Estimating in story points is typically faster

* My ideal days are not your ideal days


Why Ideal Days
--------------

* Ideal days are easier to explain outside the team

* Ideal days are easier to estimate at first

* Ideal days make velocity predictions easier


============================
Part III. Planning for Value
============================


9. Prioritizing Themes
======================

The responsibility for prioritizing is shared among the whole team but the effort is led by the product owner.

It is generally difficult to estimate the value of small units of functionality, such as a single user story. To get around this, individual user stories or features are aggregated into themes. Stories and themes are then prioritized relative to one another for the purpose of creating a release plan. Themes should be selected such that each defines a discrete set of user- or customer-valued functionality. 


Factors in Prioritization
-------------------------

1. The financial value of having the features

   Often, an ideal way to determine the value of a theme is estimate its financial impact over a period of time, usually the next few months, quarters, or possibly years. Because of the complexity in doing this, it is often useful to have an alternate method for estimating value. Since the value of a theme is related to the desirability of that theme to new and existing users, it is possible to use non-financial measures of desirability to represent value. 
                        
2. The cost of developing (and perhaps supporting) the new features

   An important, yet often overlooked, aspect of cost is that the cost can change over time. The best way to reduce the cost of change is to implement a feature as late as possible - effectively when there is no more time for change.

   Themes often seem worthwhile when viewed only in terms of the time they will take. As trite as it sounds, it is important to remember that time costs money. We can turn story points into money by:  $x/point = total expense on project/total story points. Then convert points esitmate on story into money estimate, and ask yourself: will this story worth that much investment?

3. The amount and significance of learning and new knowledge created by developing the features

   On many projects, much of the the overall effort is spent in the pursuit of new knowledge. It is important that this effort be acknowledged and considered fundamental to the project. Acquiring new knowledge is important because at the start of a project we never know everything that we’ll need to know by the end of the project. The knowledge that a team develops can be classified into two areas:

   * Knowledge about the product: knowledge about what will be developed. The more product knowledge a team has, the better able they will be to make decisions about the nature and features of the product.  

   * Knowledge about the project: knowledge about how the product will be created, include what technologies will be used.

The flip side of acquiring knowledge is reducing uncertainty. At the start of a project there is some amount of uncertainty about what features the new product should contain. There is also uncertainty about how we’ll build the product. Laufer (1996) refers to these as end uncertainty and means uncertainty. End uncertainty is reduced by acquiring more knowledge about the prodcut; means uncertainty is reduced through acquiring more knowledge about the project.

4. The amount of risk removed by developing the features

   Risks can be classified as either technological or business risks. To optimally prioritize work it is important to consider both risk and value.  

   The appropriate development sequence for the features is high-value-high-risk -> high-value-low-risk -> low-value-low-risk, and low-value-high-risk feature should be avoid.

   The high-value, high-risk features should be developed first. These features deliver the most value and working on them eliminates significant risks. Next are the high-value, low-risk features. These features offer as much value as the first set but they are less risky. They can therefore be done later in the schedule. Because of this, use the guideline to work first on high-value features but use risk as a tie-breaker.

   Be aware that a feature’s risk and value profile changes over time. 

Because most projects are undertaken to either save or make money, the first two factors often dominate prioritization discussions. However, proper consideration of the influence of learning and risk on the project is critical if we are to prioritize optimally.

To combine the four prioritiziaton factors, think first about the value of the feature relative to what it would cost to develop today. This gives you an initial priority order for the themes. Those themes with a high value-to-cost ratio are those that should be done first. Next, think of the other prioritization factors as moving themes forward or backward. 


10. Financial Prioritization
============================

Calculating
-----------

Forecasting the financial value of a theme is the responsibility of the product owner but it is a responsibility shared with all other team members. The way I like to determine the financial value of a theme is to hold a meeting (or serveral meeting) attended by as many of these individuals as practical, to generate a table for each theme like this:

------------------------------------------------------------------------------------------------
Quarter   | New Revenue   | Incremental Revenue   | Retained Revenue  | Operational Efficiencies
------------------------------------------------------------------------------------------------

The return on a project can come from a variety of sources. For convenience, we can categorize these into new revenue, incremental revenue, retained revenue, and operational efficiencies. While it is common for one category to dominate the return of a specific project, most projects will earn returns from more than one category.

* New revenue is revenue from new users.
* Incremental revenue is that from existing users.
* Retained revenue is the revenue an organization will lose if the project is not performed.
* Operational Efficiencies: No organization is ever as efficient as it could be. There’s always some task that could be streamlined or eliminated altogether. If you’re developing software for use by internal customers you are probably quite aware of the importance of operational efficiencies. However, even if you’re working on commercial software that is sold to others outside your company, some tasks within your project may still contribute to improving operational efficiencies. In your case, though, most often this will refer to your own inefficiency. e.g. anything that takes a long time or that would take a long time if the company grew, better integration or communciation between departments, reduced employee turnover, shorter training time for new employees, any time-sensitive process, combining multiple processes, anything that improves accuracy and reduces rework

(The categories here are only suggestions. You should change them if they're not appropriate for your project.)

The table includes a row for each quarter in the next two years. The time-frame is up to the team. In some cases, teams may want to look at monthly returns for one or two years. In other cases, quarterly forecasts are adequate. I find that looking out two years works well on most projects. It strikes a good balance between guessing at the distant future and looking far enough ahead. Because of the high amount of uncertainty on software development projects, others concur (Bills 2004).

The table also includes columns for various types of return a theme may have. If your project has different types of returns, use different column headings. Similarly, use different column headings if a theme will benefit from more specific column headings (perhaps “Increased Revenue from U.S. customers” and “Increased Revenue for European customers”). It is not necessary to estimate all themes with the same set of columns.

Where do these numbers we can fill in the table come from? Hopefully from some market research that was used in the business case that initiated the project. At a minimum, who ever is requesting the theme should be able to quantify the reasons for developing it.

We also need to estimate the expected development cost of the theme:

---------------------------------------------------------------------------------------------------------------------------------------
Role  | Annual Salary   | Fully Burdened Labor Cost   | Burdened Cost Per Iteration   | Time on Project   | Adjusted Cost Per Iteration
---------------------------------------------------------------------------------------------------------------------------------------

It is often useful to know the cost per story point (or ideal day). To calculate this, divide the adjusted cost per iteration by the team’s average or expected velocity.

Finally we put the two tables together:

-------------------------------------------------------------------------------------------------------------------------------------
Quarter   | Development Cost  | New Revenue   | Incremental Revenue   | Retained Revenue  | Operational Efficiencies  | Net Cash Flow
-------------------------------------------------------------------------------------------------------------------------------------


The Time Value of Money
-----------------------

Money today is more valuable than money next Tuesday. ROI (return on investment) calculations put equal value on the money invested in year one and the money earned in year five, which is a problem. To determine the value today of a future amount of money, we think in terms of how much money would have to be put in the bank today in order for it grow to the future amount. To buy a ¤5 hamburger next Tuesday, I might need to put ¤4.99 in the bank today. The amount I have to invest today in order to have a known amount in the future is called the present value. As a simple case, if I can earn 10% on my money and want to have ¤1.00 a year from now, I need to invest ¤0.91 today. In other words, with a 10% interest rate, ¤0.91 is the present value of ¤1.00 in a year.

The process of moving future amounts back into their present value is known as discounting. Clearly the interest rate that is used for discounting future amounts is critical to determining the present value of a future amount. The rate by which organizations discount future money is known as their opportunity cost, and reflects the percentage return that is passed up in order to make this investment. We all - individuals and organizations - have various opportunities for investing our money. I can put my money into a bank saving account or I can invest in stocks. I can invest it in real estate or I can put it under my mattress. Organizations can invest their money in these same ways or they can invest money on various projects. If an organization has typically earned 20% on past projects, new projects must be assessed against this same 20%. The organization’s opportunity cost is 20% because an investment in a new project means that the organization gave up the opportunity to invest in some other project, which would have earned 20%.


Measures
--------

Having come up with a way of estimating the cash flow stream that will be generated by each theme, we next turn our attention to various ways of analyzing and evaluating those cash flow streams.

* Net Present Value (NPV)

  NPV(i) = ∑(t=0,n).Ft*(1+i)^-t
  
  i is the interest rate, Ft is net cash flow in period t.

  Using Net Present Value to compare and prioritize themes has the advantages of being easy to calculate and easy to understand. The primary disadvantage to NPV is that comparing the values of two different cash flow streams can be misleading. For example, suppose we are trying to choose between two projects. The first project requires huge upfront investments but has an NPV of ¤100,000. The second project requires only a small upfront investment but also has an NPV of ¤100,000. Clearly we’d prefer to make the investment in the theme that ties up less cash but that has the same NPV. What we’d really like is to express the return on a theme in percentage terms so that we can directly compare themes.

* Internal Rate of Return (IRR, sometimes called Return On Investment, or ROI)

  IRR provides a way of expressing the return on a project in percentage terms. Where NPV is a measure of how much money a project can be expected to return (in today’s present value), IRR is a measure of how quickly the money invested in a project will increase in value. Many organizations will specify a minimum attractive rate of return or MARR. Only projects or themes with an IRR that exceeds the MARR will be funded. It is impractical to set a similar threshold for NPV since NPV values are highly dependent on the magnitude of the project. If an NPV threshold were in place then small (but valuable) projects would never be approved.

  IRR is defined as the interest rate at which the NPV of a cash flow stream is equal to 0. In other words, it is the value for i* such that:

  0 = PV(i*) = ∑(t=0,n).Ft*(1+i)^-t

  Note:
  - The first one or more items in the cash flow stream must be expenses. (Note that there must be at least one.)
  - Once the cash flow stream turns positive, it must remain positive.
  - The sum of the positive items is larger than the sum of the negative items. That is, money is made overall.

  A first advantage to using IRR is that there is no requirement to establish (or, in the worst case, guess at) an organization’s discount rate as is necessary when calculating NPV. A second advantage to IRR is that it can be used directly in comparing projects. A project with a 45% IRR has a higher return on its investment than does a project with a 25% IRR. You cannot usually use IRR in isolation, though, for making decisions. For example, suppose the project returning 45% is very small so the 45% return comes on a small investment yet the project ties up a critical developer. Further, suppose that the project returning 25% does so against a large investment but requires the same critical developer. You may choose to make more money by doing the second project, the one with the lower IRR.

  A first disadvantage to IRR is that because the calculation is hard to do by hand, the result may be more subject to distrust by some. A second disadvantage is that IRR cannot be calculated in all situations. As we saw above, three preconditions must be met in order to calculate a meaningful IRR.

* Payback period

  Payback period is the amount of time required to earn back the initial investment

  There are two primary advantages to using payback period when comparing and prioritizing themes. First, the calculations and interpretation are straight-forward. Second, it measures the amount and duration of financial risk taken on by the organization. The larger the payback period, the riskier the project because anything could change during that period.

  The primary disadvantage to payback period is that it fails to take into account the time value of money. Money received three years in the future is valued as highly as money paid out today. The second drawback to payback period is that it is not a measure of the profitability of a project or theme. Payback period will tell us that an organization will recover its money in seven quarters, but it doesn’t address how much money will be made.

* Discounted payback period

  It is easy to remedy the first drawback of the payback period calculation. To do so we simply apply the appropriate discount factor to each item in the cash flow stream.


Comparing Returns
-----------------

As you assess each theme, you build up information that can be used to compare the themes and make the prioritization decisions that are driving this analysis. The results of valuing multiple themes can be presented in a table like the one shown in table below. A table such as this lets an organization quickly and effectively review its options and choose to work on the highest-valued themes.

---------------------------------------------------------------------------
Theme   | Story Points  | Cost  | NPV   | ROI   | Discounted Payback Period
---------------------------------------------------------------------------

Making a decision is not cut and dry; the product owner and team will need to consider a variety of situationally-specific factors such as the organization’s tolerance for risk, need for short payback periods, availability of resources, other options for investment money, and so on.

For More on Project Economics: "Return on Software: Maximizing the Return On Your Software Investment", Steve Tockey, 2004.


11. Prioritizing Desirability
=============================

Kano Model of Customer Satisfaction
-----------------------------------

The process was originated by Noriaki Kano (1984). Kano’s approach gives us a way to separate features into three categories:

  * Threshold, or must-have, features

  Threshold features are those that must be present in the product for it to be successful. They are often referred to as must-have features. Improving the performance or amount of a threshold feature will have little impact on customer satisfaction.

  * Linear features

  A linear feature is one for which “the more, the better” holds true. The bigger the hotel room is, the better. These are called linear features because customer satisfaction is correlated linearly with the quantity of the feature. The better one of these features performs (or the more of it there is), the more satisfied the customers will be. Because of this, product price is often related to linear attributes.

  * Exciters and delighters

  Exciters and delighters are those features that provide great satisfaction, often adding a price premium to a product. However, the lack of an exciter or delighter will not decrease customer satisfaction below neutral. The built-in television on the hotel’s treadmill was an exciter for me. I would not have been dissatisfied if the hotel didn’t offer these because I didn’t know anyone had them. In fact, exciters and delighters are often called unknown needs because customers or users do not know they need these features until they see them.


Because must-have features are required for a product to even play in its market segment, emphasis should be placed on prioritizing the development of all threshold features. A product’s must-have features do not need to be developed in the first iterations of a release. However, since users consider these features as mandatory, they need to be available before the product is released. Keep in mind, though, that partial implementation of must-have features may be adequate since gains in customer satisfaction drop off quickly after a base level of support for threshold features has been established. 

Secondary emphasis should be placed on completing as many linear features as possible. Because each of these features leads directly to greater customer satisfaction, the more of these features that can be included, the better. (Excluding, of course, such situations as a product that is already bloated with too many features.) Finally and with time permitting, at least a few delighters should be prioritized such that they are included in the release plan.


The easiest way to make use of a Kano model on an agile project is to think about each theme and make an educated guess about the type of each. A much better way, however, is to speak with customers or users in order to truly determine the type of each theme. This is surprisingly easy because it can be done with a written questionnaire and you may need to survey as few as 20–30 users to accurately prioritize requirements.

Kano proposed determining the category of a feature by asking two questions: one question regarding how the user would feel if the feature were present in the product and one question about how the user would feel if it were absent. The answers to these questions are on the same five-point scale:

  1. I like it that way
  2. I expect it to be that way
  3. I am neutral
  4. I can live with it that way
  5. I dislike it that way

Answsers from one user can be inconsistent. By cross-referencing the answer to the functional question with the answer to the dysfunctional question, a prospective user’s responses can be reduced to a single meaning. We use the table:

Customer      | Dysfunctional Question
Requirements  | Like | Expect | Neutral | Live with | Dislike
-------------------------------------------------------------
F Q| Like     | Q    | E      | E       | E         | L
u u|--------------------------------------------------------- 
n e| Expect   | R    | I      | I       | I         | M
c s|--------------------------------------------------------- 
t t| Neutral  | R    | I      | I       | I         | M
i i|---------------------------------------------------------
o o| Live with| R    | I      | I       | I         | M
n n|---------------------------------------------------------
a  | Dislike  | R    | R      | R       | R         | Q
l  |---------------------------------------------------------

M   Must-have
R   Reverse
L   Linear
Q   Questionable
E   Exciter
I   Indifferent

If we repeat this process over 20–30 users their answers can be aggregated and their distributions determined as is shown in table below:

------------------------------------------------------
Theme   | E   | L   | M   | I   | R   | Q   | Category
------------------------------------------------------

Occasionally you’ll encounter a feature that has high values for two responses. This indicates that different types of customers and users have different expectations. In these cases you should consider analyzing responses based on some factor that differentiates your customer or user sub-population. You may, for example, separate answers from users at small companies from users at large companies. Or you may choose to separate answers based on job role within a company or by industry segment.


Relative Weighting
------------------

Karl Wiegers (1999) has recommended an approach that is similar to Kano’s in that considers both the positive benefit of the presence of a feature and the negative impact of its absence. Rather than use questionnaires, this approach relies on expert judgment. Collaboratively, but led by the product owner, the team assesses each feature being considered for the next release. Each feature is assessed in terms of the benefits it will bring if implemented as well as the penalty that will be incurred if it is not implemented. As with estimates of story points and ideal time, the estimates of benefits and penalties are relative. A scale of 1–9 is used. See table below:

--------------------------------------------------------------------------------------------------------------
Feature   | Relative Benefit  | Relative Penalty  | Total Value   | Value %   | Estimate  | Cost %  | Priority
--------------------------------------------------------------------------------------------------------------
...
--------------------------------------------------------------------------------------------------------------
Total     |                   |                   |               |           |           |         |
--------------------------------------------------------------------------------------------------------------


For each feature, the relative benefit and penalty are summed and entered into the Total Value column. If you wish, you could weight the benefits and penalties. For example, to weight the relative benefit as twice as important as the relative penalty, multiply the Relative Benefit by 2 before adding it to Relative Penalty to get the Total Value. The sum of the Total Value column represents the total value of delivering all features. To calculate the relative contribution of each feature, divide its total value by the sum of the Total Value column (fill it in Value % column).The Estimate holds the story point or ideal days estimate. Exactly as with Total Value, the Estimate column is summed and the percentage of each estimate is calculated in the Cost % column. The final column, Priority, is calculated by dividing the Priority % by the Cost %. Higher numbers represent higher priorities because they will create more value for the effort invested in them.


12. Splitting User Stories
==========================

When to Split A User Story:

* It is too large to fit within a single iteration. 
* A story may be small enough to fit within an iteration but it won’t fit within the iteration being planned because there isn’t enough room. The team may feel they will have time to develop a portion of a story in the iteration, but not the entire story.
* It can be useful to split a large user story (an epic) if a more accurate estimate is necessary. 


Splitting Tricks:

* Splitting Across Data Boundaries

  One of the best ways to split a large user story is by the data that will be supported. Like for a financial project, we can split an epic story "As a user I can enter my balance sheet information." into "As a user, I can enter summary balance sheet data.", "As a user, I can enter categorized balance sheet data.", "As a user, I can enter detailed loan informaton" and so on, since a balance sheet in this case could include a great many fields (at the highest level it includes assets and liabilities, assets included such items as cash, securities, real estate, automobiles, loans, and so on).

  In some cases a large story can be made much smaller by removing the handling of exceptional or error conditions from the main story. 

* Splitting On Operational Boundaries

  Split large stories based on the operations that are performed within the story. Like split a complicated search story into basic search, advanced search and so on. A common approach to doing this is to split a story along the boundaries of the common CRUD operations—Create, Read, Update, and Delete.

* Removing Cross-Cutting Concerns

  Consider removing cross-cutting concerns (such as security, logging, error handling, and so on) and creating two versions of the story: one with and one without support for the cross-cutting concern.

* Don't Meet Performance Constraints

  Considering splitting a large story by separating the functional and non-functional aspects into separate stories.

* Split Stories of Mixed Priority

* Don't Split A Story into Tasks

  The best way to avoid this temptation is to follow Hunt and Thomas’ advice (1999) to fire a tracer bullet through the system. A tracer bullet travels through all layers of a feature. That may mean delivering a partial user interface, a partial middle tier, and a partial database. Delivering a cohesive subset of all layers of a feature is almost always better than delivering all of one layer. This leads to another guidline: Don’t split a large story into tasks. Instead, try to find a way to fire a tracer bullet through the story.

* Avoid The Temptation of Related Changes

  Once you’ve split a story and have it at an appropriate size, don’t make things worse by adding work to the story. Often this comes in the form of the temptation of related changes. We tell ourselves, “While I’m in that code, I might as well take care of these other lingering changes...” It can very possibly be appropriate to fix a bug or address an old issue while working on a separate issue in the same part of the code. However, the prioritiy of doing so needs to be considered in the same manner in which priorities were considered for other features. In other words, which is higher priority: spending a half-day fixing a year-old bug or spending the same amount of time on something else? The answer is clearly entirely contextual and becomes this chapter’s final guideline: Avoid making things worse by adding related changes to an appropriately sized feature, unless the related changes are of equivalent priority.

* Combining Stories

  With all of this advice about splitting stories, it may be tempting to think that every user story a team is about to work on should be made as small as possible. Tha’s not the case. For teams working in two-week iterations, splitting features such that each can be done in 2–5 days or so is appropriate. (Stories are still estimated in story points but by the time a team needs to split stories they will know approximately how many story points or ideal days equates to around 2–5 days.) Stories will need to be a little smaller for one-week iterations and can, but don’t need to, be a little larger for longer iterations. Stories of these approximate sizes flow best through the short iterations of an agile project.

  Just as we may need to split large stories, we may need to combine multiple tiny stories. The combined stories are estimated as a whole rather than individually. When possible try to combine related stories as that will make it easier to prioritize them. It is very common to combine multiple bug reports and treat them as one unit.


===================
Part IV. Scheduling
===================


13. Release Planning Essentials
-------------------------------

Release planning is the process of creating a very high-level plan that covers a period longer than an iteration. A typical release will cover perhaps three to six months and maybe three to twelve or more iterations, depending on how long the iterations are. A release plan is important for a number of reasons:

1. It helps the product owner and the whole team decide how much must be developed and how long that will take before they have a releasable product.
2. It conveys expectations about what is likely to be developed and in what timeframe. Many organizations need this information because it feeds into other strategic planning activities.
3. It serves as a guidepost toward which the project team can progress. Without the concept of a release, teams move endlessly from one iteration to the next. A release plan provides context that allows iterations to combine into a satisfying whole. This is a fundamental concern with any iterative process, not just agile ones.


The Release Plan
----------------

Part of planning a release is determining how much can be accomplished by what date. In some cases we start with a date and see how much can be finished by then. In other cases we start with a set of user stories and see how long it will take to develop them. In both cases, once a team has an initial answer, it is assessed against the organization’s goals for the project: Will the product developed make the desired amount of money? Will it save enough money? Will the product capture the target market share? If not, perhaps a longer or shorter project may achieve an acceptable set of goals.

At a cursory level, determining how much work will fit into a release and what user stories that will be is a very straightforward process. Multiplying the planned number of iterations by either the expected or known velocity of the team gives us the total amount of work that can be performed.

During release planning we do not want to create a plan that indicates which developers will work on which user stories or tasks or the sequence in which work will be performed within an iteration. Creating a plan with that level of detail is dangerous and misleading during release planning. Decisions about who works on what and the sequence of activities are best left to the individuals working on those tasks and are best deferred as long as possible. Additionally, remember that items in a release plan are user stories, which are descriptions of the functionality to be delivered, not individual engineering tasks to be performed. During release planning it is too early and some user stories may be insufficiently understood to be disaggregated into engineering tasks. The team will eventually disaggregate the user stories of the release plan into their constituent tasks. But, they won’t do this until the beginning of the iteration containing those stories.

Naturally, should your project, organization, and work environment warrant it, you can include additional information in a release plan. For example, you may wish to communicate some key assumptions underlying the plan (who is on the team, how long an iteration will be, etc.).

The general steps to planning a release is:

1 .Determine conditions of satisfaction
2. Estimate user stories
3. Select iteraion length, Estimate Velocity, Prioritize user stories
4. Select stories and a release date
5. goto 1

* Determine the Conditions of Satisfaction

  Before starting to plan a release, it is important to know the criteria by which the project will be evaluated as a success or a failure. For most projects, the ultimate scorecard is the amount of money saved or generated. As leading indicators of whether a project is likely to achieve these financial goals, most projects use the triumvirate of schedule, scope, and resources. For most projects, this means that the product owner’s conditions of satisfaction are defined by a combination of schedule, scope, and resource goals.

  The product owner will bring desired targets for each of these factors into almost every release planning meeting. A product owner may want four themes (worth 200 story points) developed in three months without adding personnel, for example. While a target for each factor is often identified, one is usually preeminent. Many project ares either date-driven or feature-driven. A date-driven project is one that must be released by a certain date but for which the feature set is negotiable. A feature-driven is one that we would probably like to release as soon as possible but consider the completion of a set of features more important.

* Estimate The User Stories

  Because an estimate represents the cost of developing a user story, it is important that each has been estimated. It is not necessary to estimate everything that a product owner may ever want. It is only necessary to have an estimate for each new feature that has some reasonable possibility of being selected for inclusion in the upcoming release. Often, a product owner will have a wish list that extends two, three, or more releases into the future. It is not necessary to have estimates on the more distant work.

* Select an Iteration Length

  Most agile teams work in iterations of from one to four weeks. It’s possible to go slightly longer and some teams have experimented with even shorter iterations. When planning a release, an appropriate iteration length will need to be chosen.

* Estimate Velocity

  If the team has experience working together, your best bet is often to use the velocity the team exhibited most recently. Naturally, if the technology or business domain changed dramatically, it may not be appropriate to use a team’s past velocity. Still, there are techniques you can apply that enable you to make an informed estimate of velocity based on past results. We'll discuss that later.

* Prioritize User Stories

  Most projects have either too little time or too many features. It is often impossible to do everything that everyone wants in the time allowed. Because of this, the product owner must prioritize the features she wants developed. A good product owner will accept ultimate responsibility for prioritizing, but will listen to advice from the development team, especially about sequencing.

* Select Stories and A Date

  If the project is feature-driven, we can sum the estimates of all needed features and divide by the expected velocity. This will give us the number of iterations necessary to complete the desired functionality.

  If the project is date-driven, we can determine the number of iterations by looking at a calendar. Multiplying the number of iterations by the expected velocity will tell us how many story points or ideal days will fit in the release. We can count off that many points or ideal days into the prioritized list of user stories and see how much functionality can be delivered in the desired time.

  The next question to be addressed regards how detailed the release plan will be. Some teams in some environments prefer to create a release plan that shows what they expect to develop during each iteration. Other teams prefer simply to determine what they think will be developed during the overall release, leaving the specifics of each iteration for later. This is something to be discussed and decided during release planning.

  There are advantages and disadvantages to each approach. Obviously, assigning specific features to specific iterations takes more time. However, the additional detail this provides can be useful when coordinating work among multiple teams. On the other hand, not allocating work to specific iterations provides less detail, but it takes much less time. Further, even if we do preliminarily assign work to specific iterations, we do so with less knowledge than we’ll have at the start of each iteration. Undoubtedly, the plan will change as we learn more throughout the project. So, the investment of time and effort to assign work to specific iterations should be weighed against this. Still, on some projects it may be worth doing. What I find to be a good compromise is to place specific work into the first one to three iterations, treating the rest of the release plan as one large bucket. It’s almost always worth allocating specific work to the first iteration, especially if it is starting immediately.


Updating The Release Plan
-------------------------

At this point, the release plan is done. However, it’s important that the release plan isn’t filed away somewhere or put up on a shelf never to be touched again. The release plan should be revisited and updated with some regular frequency. If the development team’s velocity has remained fairly constant and iteration planning hasn’t introduced any big surprises, you may want to go as long as four to six weeks without formally updating the release plan. On the other hand, many projects benefit from establishing a rule that the release plan will be revisited after each iteration.

A release plan is a high-level plan that covers a period longer than an iteration. For most teams a release occurs every three to six months, but it is not unusual to have releases more or less frequently depending on the type of software.
